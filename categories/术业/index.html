<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: 术业 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">术业</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-03T16:00:00.000Z" title="3/4/2022, 12:00:00 AM">2022-03-04</time>发表</span><span class="level-item"><time dateTime="2022-03-24T15:20:34.298Z" title="3/24/2022, 11:20:34 PM">2022-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">2 分钟读完 (大约345个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/04/Notebook/Linux/Linux_Bash/">Linux Bash总结</a></h1><div class="content"><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>移动光标<br>ctrl+b: 前移一个字符(backward)<br>ctrl+f: 后移一个字符(forward)<br>alt+b: 前移一个单词<br>alt+f: 后移一个单词<br>ctrl+a: 移到行首（a是首字母）<br>ctrl+e: 移到行尾（end）<br>ctrl+xx: 行首到当前光标替换<br>编辑命令<br>alt+.: 粘帖最后一次命令最后的参数（通常用于mkdir long-long-dir后, cd配合着alt+.）<br>alt+d: 删除当前光标到临近右边单词开始(delete)<br>ctrl+w: 删除当前光标到临近左边单词结束(word)<br>ctrl+h: 删除光标前一个字符（相当于backspace）<br>ctrl+d: 删除光标后一个字符（相当于delete）<br>ctrl+u: 删除光标左边所有<br>ctrl+k: 删除光标右边所有<br>ctrl+l: 清屏<br>ctrl+shift+c: 复制（相当于鼠标左键拖拽）<br>ctrl+shift+v: 粘贴（相当于鼠标中键）<br>其它<br>ctrl+n: 下一条命令<br>ctrl+p: 上一条命令<br>alt+n: 下一条命令（例如输入ls, 然后按’alt+n’, 就会找到历史记录下的ls命令）<br>alt+p: 上一条命令（跟alt+n相似）<br>shift+PageUp: 向上翻页<br>shift+PageDown: 向下翻页</p>
<p>ctrl+r: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项</p>
<p>参考资料</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15311900/3182821">https://blog.51cto.com/u_15311900/3182821</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-08T16:00:00.000Z" title="5/9/2021, 12:00:00 AM">2021-05-09</time>发表</span><span class="level-item"><time dateTime="2021-05-10T01:50:06.000Z" title="5/10/2021, 9:50:06 AM">2021-05-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 分钟读完 (大约2360个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/09/work/005.FreeRTOS/">FreeRTOS学习笔记02</a></h1><div class="content"><h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><p><strong>FreeRTOS</strong>是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要。</p>
<p>FreeRTOS是为小型嵌入式系统设计的可裁剪实时内核。其主要特点有：</p>
<ul>
<li>调度器支持抢占式调度，协助式调度，或者两者混合。时间片可选</li>
<li>占用空间小，简单，易用</li>
</ul>
<h3 id="FreeRTOS的源码结构"><a href="#FreeRTOS的源码结构" class="headerlink" title="FreeRTOS的源码结构"></a>FreeRTOS的源码结构</h3><p>在FreeRTOS v9.0版本中，FreeRTOS的代码主要包含两个文件夹：FreeRTOS_CORE和FreeRTOS_PORTABLE。这两个文件夹下包含多个.C文件。</p>
<ul>
<li>port.c: 针对不同硬件平台的接口，定义与硬件接口相关的代码</li>
<li>heap_4.c： 内存管理相关</li>
<li>croutine.c：协程相关</li>
<li>event_groups.c：事件标志组相关</li>
<li>list.c：管理系统实际会应用到list，是FreeRTOS的一种基础数据结构</li>
<li>tasks.c：任务创建、挂起、恢复、调度相关</li>
<li>timers.c：软件定时器相关</li>
<li>queue.c：管理tasks之间的通信(message queue的概念)</li>
<li>FreeRTOSConfig.h：宏定义，配置RTOS所需要的资源</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AndreLYL/BlogPictures/blog_files/img/20210508182833.png"></p>
<h3 id="FreeRTOS的任务间通信机制"><a href="#FreeRTOS的任务间通信机制" class="headerlink" title="FreeRTOS的任务间通信机制"></a>FreeRTOS的任务间通信机制</h3><p>裸机编程中，一个复杂的功能通常需要多个子函数来实现，不同的子函数之间的通常采用一些全局变量来实现联系。在RTOS中，我们不仅可以使用全局变量，还可以采用系统自带的任务间通信机制。这种机制更加受推荐。其原因是：</p>
<ol>
<li>阻塞等待机制比轮询等待更加高效：全局变量当用作某种事件的标志是，获取该标志的任务需要轮询检测标志位的状态是否变化。这样会产生大量的无效判断。如果使用任务间通信阻塞等待的机制，CPU可以转而处理其他事情，当标志变化时解除阻塞。又可以及时执行后续的处理。</li>
<li>全局变量会产生不可重入函数导致逻辑混乱：RTOS运行时，CPU需要调用不同的函数，如果全局变量使用不恰当，会导致原本设计的逻辑产生混乱。比如某个低优先级任务正在访问某个公共函数，并对函数中的全局变量进行了修改。还未退出函数时，更高优先级的任务抢占了CPU的使用权，并对该函数的全局变量进行了修改。此时低优先级任务若认为自己修改变量成功，执行后续逻辑时，就会发生错误。</li>
</ol>
<p>FreeRTOS任务间的通信方式：</p>
<ul>
<li>信号量(Semaphore): 用于任务间的同步，一个任务以阻塞方式灯带另一个任务释放信号量。</li>
<li>互斥量(Mutex)：用于任务间共享资源的互斥访问，使用前获取锁，使用后释放锁。</li>
<li>事件标志组(EventGroup): 用于任务间的同步，相比信号量，事件标志组可以等待多个事件的发生。</li>
<li>消息队列(Queue): 类比全局数据，它可以一次发送多个数据(一般将数据定义成结构体发送)，每次数据的大小固定不变。</li>
<li>流缓冲区(SteamBuffer)：在队列的基础上，优化的一种更加适合的数据结构，可以一次写入任意数量的字节，并且可以一次读取任意数量的字节。</li>
<li>消息缓冲区(MessageBuffer)：在流式缓冲区的基础上实现的，可以对消息进行设计改进。每一条消息的写入增加了一个字节用来表示该消息的长度，读取时需要至少一次性读出一条消息，否则会返回0.</li>
<li>任务通知(Notify): 不同于上面的任务通信方式(使用某种通信对象，通信对象是独立于任务的实体，有单独的存储空间，可以实现数据的传递和较复杂的同步，互斥功能)， 通知是发向一个指定的任务的，直接改变该任务 TCB的某些变量。</li>
</ul>
<h3 id="FreeRTOS队列"><a href="#FreeRTOS队列" class="headerlink" title="FreeRTOS队列"></a>FreeRTOS队列</h3><p>在实际应用中，一个任务或中断服务函数经常需要和另一个任务进行消息传递。裸机情况下通常通过全局变量实现。但是操作系统使用全局变量的方式会涉及“资源管理”问题。<strong>FreeRTOS中采用队列机制完成任务与任务，和任务与中断之间的消息传递。</strong> 队列可以存储有限的，大小固定的数据项目。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>FreeRTOS创建任务、队列、信号量有两种方法：</p>
<p>第一种是<strong>由用户自行定义所需的RAM</strong>，这种方法也叫静态的方法。静态方法的函数一般由Static结尾，比如任务创建 <code>xTaskCreateStatic()</code>。 使用此函数创建任务的时候需要用户定义任务堆栈。</p>
<p>另一种是<strong>动态的申请所需的RAM</strong>，使用动态内存管理时，FreeRTOS内核在创建任务、队列、信号量的时候会动态的申请RAM。C语言标准库的malloc()和free()也可以实现动态内存管理，但这种方法在小型嵌入式系统中效率不高，会占用很多代码空间，并且他们的线程不是安全的，程序执行的时间也是不确定的，此外还会导致内存碎片。因此在FreeRTOS中，内核采用 <code>pvPortMalloc()</code>代替 <code>malloc()</code> 申请内存，采用 <code>vPortFree()</code>函数释放内存。<strong>关于内存分配，FreeRTOS提供了5这种内存分配的方法：</strong> 也就是在5个.c文件，heap_1.c, heap_2.c, heap_3.c, heap_4.c, heap_5.c。</p>
<p><strong>内存碎片：</strong><br>内存分配与管理的方法中需要解决的问题之一就是内存碎片，其产生过程如下图所示，一个新的内存堆被系统按照应用需求分成多个大小不同的内存块。应用在使用完内存后就会进行释放，同时新的应用产生也需要分配新的可用该内存。经过多次申请和释放后，内存块被不断地分割，导致内存中存在大量的很小的内存块。这些内存块太小导致大多数应用无法使用，因此就形成了内存碎片。这些内存碎片的不断增加会导致实际可用内存越来越少。最终应用程序因为分配不到合适的内存而崩溃。而FreeRTOS的heap_4.c就提供了一个解决内存碎片的方法，即将内存碎片进行合并组成一个新的可用的大内存块。<br><img src="https://cdn.jsdelivr.net/gh/AndreLYL/BlogPictures/blog_files/img/20210509005027.png"></p>
<p><strong>heap_1.c简介</strong><br>动态内存分配需要一个内存堆，在FreeRTOS中的内存堆为ucHeap[],大小为configTOTAL_HEAP_SIZE.</p>
<p>heap_1特性如下：</p>
<ol>
<li>使用一旦创建好任务，信号量和队列就再也不会删除的应用，实际上大多数的FreeRTOS的应用都是这样的。</li>
<li>具有可确定性(执行所花费的时间大多数都是一样的)，而且不会导致内存碎片。</li>
<li>代码实现和内存分配的过程都非常简单，内存是从一个静态的数组中分配的，也就是适合与那些不需要动态分配内存的应用。</li>
</ol>
<p><strong>heap_2.c简介</strong></p>
<p><strong>heap_3.c简介</strong></p>
<p><strong>heap_4.c简介</strong><br>heap_4提供了一个最优的内存分配方法，不像heap_2, heap_4会将内存中的碎片合并成一个大的可用内存块，他提供了内存合并算法。内存堆为ucHeap[], 大小同样为configTOTAL_HEAP_SIZE。可以通过函数xPortGetFreeHeapSize()获取剩余内存大小。</p>
<p>heap_4特性如下：</p>
<ol>
<li>可以用在那些需要重复创建和删除任务、队列、信号量和互斥信号量等应用中。</li>
<li>不会像heap_2那样产生严重的内存分配碎片，即使分配的内存大小是随机的。</li>
<li>具有不确定性，但是远比C标准库的malloc()和free()效率高。</li>
</ol>
<p><strong>heap_5简介</strong><br>heap_5使用了heap_4相同的合并算法，内存管理实现基本相同，但是heap_5允许内存堆跨越多个不连续的内存段。如果使用heap_5需要调用函数xPortDefineHeapRegions()来对内存堆做初始化处理，该函数执行完之前禁止调用任何会调用pvPortMalloc()的函数。</p>
<p>参考资料：<br>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336687316">FreeRTOS源码探析之——任务调度相关</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-06T16:00:00.000Z" title="5/7/2021, 12:00:00 AM">2021-05-07</time>发表</span><span class="level-item"><time dateTime="2021-07-19T11:36:54.000Z" title="7/19/2021, 7:36:54 PM">2021-07-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">23 分钟读完 (大约3522个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/07/work/004.RTOS/">FreeRTOS学习笔记01</a></h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><strong>操作系统</strong>：操作系统是一个用以提供基础计算机功能的计算机程序，它可以向其他程序提供服务，应用来实现用户想要实现的功能。操作系统对应用程序的支持使得开发者在在开发应用程序是更加快捷，简单，易维护。</p>
</li>
<li><p><strong>RTOS</strong>：大部分操作系统允许多个应用程序同时执行，这种成为多任务。但实际上，在任何一个时间点上只有一个进程在独立执行。由于应用程序切换足够快，好像所有的程序同时执行。操作系统中有一个调度器(Scheduler)的部分负责调度应用程序，决定什么时候执行哪个应用程序，调度器在每个程序之间的切换需要足够快速。实时操作系统费的调度器设计成可以提供确定的执行模式。实时性意味着嵌入式系统对某个具体事件的响应必须严格控制在一个预定的deadline内。<strong>实时操作系统会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</strong></p>
</li>
<li><p><strong>线程</strong>：线程是操作系统能够进行运算调度的最小单位，包含在进程中，是进程的实际运作单位。一条线程是进程中的一个单一控制流。线程有四枣红基本状态：产生，阻塞，非阻塞，结束。</p>
</li>
<li><p><strong>进程</strong>：指计算机已运行的程序，是分时系统的基本运作单位。进程是程序的真正运行实例。进程有五种状态：新生，运行，等待，就绪，结束。在单CPU系统中，任何时间可能有多个进程在等待，但必定仅有一个进程在运行。</p>
</li>
<li><p>线程和进程区别：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，是运行中程序指令的描述。</p>
</li>
</ul>
<p><strong>实时操作系统的设计原则：</strong></p>
<ul>
<li>实时的消息、事件处理机制：常规的操作系统，消息队列是按照FIFO的方式进行调度。实时操作系统会提供基于优先级的处理方式。</li>
<li>提供内核级的优先级翻转处理方式：实时操作系统调度器最精彩遇到的问题是优先级翻转，因此对于类似信号量一类的API，都能提供抑制优先级翻转的机制，防止操作系统死锁。</li>
<li>减少粗粒度的所和长期关中断的使用：这里的所主要是指自旋锁(Spinlock)一类会影响中断的锁，也包括任何关中断的操作，在Windows和Linux的驱动中，为了同步的需要，可能会长期关闭中断，这里的长期可能是毫秒到百微秒级。但实时操作系统通常不允许长期关中断。对于非实时操作系统来说，如果收到外部中断，系统在处理中断的整个过程中可能会一直关中断。但实时操作系统的通常做法是吧中断作为一个事件通告给另外一个任务，interrupt handler在处理完关键数据以后，立即打开中断，驱动的中断处理程序以一个高优先级任务的方式继续执行。</li>
<li>系统级的服务也要保证实时性：对于一些系统级的服务，如文件系统操作，非实时系统过会缓存用户请求，并不直接把数据写入设备，或者建立一系列线程池，分发文件系统的请求。但是实时系统允许高优先级的任务有限写入数据。这种设计会牺牲性能，但是会保证系统的实时性。</li>
<li>避免提供实时性不确定的API：多数实时操作系统都不支持虚拟内存(page file &#x2F; swap area),主要原因是缺页中断(page fault)会导致任务调度的不确定性增加。多数实时操作系统过都支持分页，但很少会使用虚拟内存，因为一次缺页中断的开销十分巨大，通常都是毫秒级。会导致用户程序执行的不确定性增加。</li>
<li>提供针对实时系统调度的专用API：</li>
<li>降低系统抖动：由于关中断的原因，通常情况下，操作系统的调度器不会太精确的产生周期性的调度。一个设计优秀的实时操作系统能把抖动降低到微妙甚至是百纳秒级别。</li>
<li>针对实时性设计的SMP和虚拟化技术：</li>
</ul>
<h3 id="实时性，硬实时，软实时"><a href="#实时性，硬实时，软实时" class="headerlink" title="实时性，硬实时，软实时"></a>实时性，硬实时，软实时</h3><p><strong>实时性：</strong> 实时性也叫实时计算(real-time computing), 实时约束指的是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格时间限制内响应。 换句话说就是，任务(Task)必须在给定的时间(Deadline)内完成。比如汽车安全气囊响应，在汽车检测到撞击后，汽车ECU以及执行器需要在40ms内完全打开气囊，否则就会对乘客安全造成威胁。这个时候就要求汽车ECU的程序运行满足实时性标准。</p>
<p><strong>硬实时：</strong> The firm real-time definition allows for infrequently missed deadlines. In these applications the system can survive task failures so long as they are adequately spaced, however the value of the task’s completion drops to zero or becomes impossible.</p>
<p><strong>软实时：</strong> The soft real-time definition allows for frequently missed deadlines, and as long as tasks are timely executed their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.</p>
<p><strong>区别：</strong> 硬实时操作系统<strong>必须</strong>使任务在确定的时间内完成；软实时操作系统能使<strong>绝大多数的</strong>任务在确定时间内完成。因此，硬实时和软实时的差别是，软实时只能提供统计意义上的实时。只要任务及时执行就会具有价值，如果任务超出Deadline，只会导致价值的稍微降低。如计算机的声音系统就是软实时的任务。 而硬实时任务只要超时，任务的价值就会降低到零。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>调度同来确定多任务环境下任务执行的顺序和获得CPU资源后能执行的时间长度。操作系统通过一个调度程序来实现调度功能。调度程序以函数的形式存在，用来实现操作系统的调度算法。调度程序本身并不是一个任务，是一个函数调用，可在内核的各个部分进行调用。调用调度程序的具体位置成为一个调度点(Scheduling point), 调度点通常处于一下位置：**(i)** 中断服务程序的结束位置；**(ii)** 任务因等待资源而处于等待状态；**(iii)** 任务处于就绪状态时。</p>
<p>在操作系统中，一个任务有三种典型状态：</p>
<ul>
<li>正在运行(Running)：正在CPU中执行</li>
<li>待命(Ready)：等待执行</li>
<li>阻塞(Blocked)：任务暂停，等待一个事件的发生，例如接受一组数据</li>
</ul>
<p>由于CPU在某个事件只能执行一个任务，因此大部分任务在多数事件处于阻塞或待命状态。可能大量的项目在待命列表里等待执行。这取决于系统所需的任务数量和调度器类型。通常情况下，简单的时间触发式调度器，待命任务列表的数据结构要尽可能缩短最坏情况下，程序在调度器关键部分的执行时间，防止其他任务一直在待命列表中无法及时执行。在这种调度器中，应该尽量避免抢占式任务，甚至应该关闭调度器之外的所有中断。并且待命列表的数据结构应该根据系统所需要最大任务数量进行优化。如果列表任务较多，双向链表是一个合适的结构。在任务列表的排序上，应该按照优先级对任务进行排序。这样可以保证高优先级任务的及时执行。</p>
<p><strong>调度算法：</strong><br>实时操作系统需要采用各种算法和策略保证系统行为的可预测性，并且调用一切可利用的资源完成实时控制任务。 其实时调度算法分为三种类别：基于优先级的调度算法(Priority-driven scheduling-PD)，基于CPU使用比例的共享式调度算法(Share-drivescheduling-SD)，基于时间进程的调度算法(Time—driven schedulinq-TD)。</p>
<p>基于优先级的调度算法给每个进程分配一个优先级，在每次进程调度的时候，最高优先级任务首先被执行。算法的类型分为两种：</p>
<p>静态调度：静态调度在系统开始运行前进行调度，严格的静态调度在系统运行时无法对任务重新调度。静态调度的目标是把任务分配给各个处理机，并对每一处立即给出所要运行的静态运行顺序。静态调度算法实现简单</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>死锁：</strong> 死锁是指一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用的不会释放的资源而处于的一种永久等待的状态。</p>
<p><strong>死锁的四个条件：</strong> </p>
<ul>
<li>互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用</li>
<li>请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源</li>
<li>非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制的剥夺</li>
<li>循环等待条件(Circular wait)：系统中的若干进程组成的环路，该环路中每个进程都在灯带相邻进程正占用的资源</li>
</ul>
<p><strong>互斥锁：</strong> 互斥锁是一种独占锁，当线程A加锁成功后，此时的互斥锁已经被线程A独占了，只要A没有释放受众的锁，线程B加锁就会失败，于是就是会释放CPU让给其他线程，既然B释放了CPU，也就意味着线程B的加锁代码会被阻塞。对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。</p>
<p><strong>自旋锁：</strong> 自旋锁是一种特殊的互斥锁，当资源被加锁后，其他线程想要再次加锁，此时该线程不会被阻塞睡眠而是陷入循环等待状态(CPU不能做其他事情)，循环检查资源持有者是否已经释放了资源，这样做的好处是减少了线程从睡眠到唤醒的资源消耗，但是会一直占用CPU资源。适用于资源的锁被持有时间段，而又不希望在线程的唤醒上花费太多资源的情况。</p>
<ol>
<li>自旋锁为什么不能睡眠？<br> 因为需要循环检测lock变量。</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol>
<li><strong>介绍一下FreeRTOS的内存管理？</strong></li>
</ol>
<ul>
<li>heap_1：只申请不释放，适用于一旦创建好任务，信号量和队列就再也不会删除的应用。</li>
<li>heap_2：最佳匹配，即申请又释放，适用于可能会重复的删除的任务，队列，信号量等应用中，需要注意内存碎片的产生问题。</li>
<li>heap_3：简单封装malloc,free,对其进行线程保护。使用时需要编译器提供一个内存堆，编辑器库需要提供malloc()和free()函数。</li>
<li>heap_4：最佳匹配+合并相邻内存，具有不确定性，但不会产生严重的内存碎片</li>
<li>heap_5：最佳匹配+合并不连续的内存区。</li>
</ul>
<ol start="2">
<li><strong>简述RTOS中，栈空间的最大使用率和栈溢出的检测方法？</strong></li>
</ol>
<ul>
<li>方法一：在任务切换时检测任务指针是否越界，如果越界就会在任务切换时触发栈溢出的钩子函数</li>
<li>方法二：在任务创建的时候将任务战所有数据初始化为0Xa5，任务切换进行任务栈检测时检测末尾的16个字节是否都是0xa5，通过这种方式检测栈是否溢出。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012993936/article/details/41145863">https://blog.csdn.net/u012993936/article/details/41145863</a><br>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86861756">https://zhuanlan.zhihu.com/p/86861756</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-02T16:00:00.000Z" title="5/3/2021, 12:00:00 AM">2021-05-03</time>发表</span><span class="level-item"><time dateTime="2022-03-24T15:16:02.396Z" title="3/24/2022, 11:16:02 PM">2022-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 分钟读完 (大约2386个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/03/work/Emmbed_system_QA/">嵌入式面试常见问题整理</a></h1><div class="content"><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="单工，半双工，全双工"><a href="#单工，半双工，全双工" class="headerlink" title="单工，半双工，全双工"></a>单工，半双工，全双工</h4><ul>
<li>单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。</li>
<li>半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。</li>
<li>-全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。</li>
</ul>
<h4 id="FLASH-和-EEPROM区别"><a href="#FLASH-和-EEPROM区别" class="headerlink" title="FLASH 和 EEPROM区别"></a>FLASH 和 EEPROM区别</h4><p>基本概念：</p>
<ul>
<li>ROM： Read-Only Memory</li>
<li>RAM： Random Access Memory</li>
<li>FLASH: Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据</li>
<li>EEPROM: Electrically-Erasable Programmable Read-Only Memory</li>
<li>SRAM：静态RAM，读写速度非常快，比较昂贵。一般用于CPU的一级缓冲，二级缓冲。</li>
<li>DRAM：动态RAM，DRAM保留数据的时间很短，速度比SRAM慢，但是比任何ROM快。计算机的内存是DRAM。</li>
</ul>
<p>FLASH和EEPROM的最大区别是FLASH按扇区操作，EEPROM则按字节操作，二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。</p>
<p>目前的单片机，RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据. </p>
<ol>
<li><strong>Nano Flash和NOR Flash的区别：</strong><br>目前Flash主要有NANO和NOR两种</li>
</ol>
<ul>
<li>NOR Flash：该种Flash的读写和创建的SDRAM读写一样，用户可以直接运行装载在NOR Flash里面的代码，这样可以减少SRAM的容量从而节约成本。</li>
<li>NANO Flash：NAND Flash没有采取内存的随即读取技术，它的读取是一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价，用户无法直接运行上面的代码。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-0f09c39ef43d96bbb68864e85ed9fcd0_720w.jpg"></p>
<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><h4 id="CAN总线协议-Controller-Area-Network"><a href="#CAN总线协议-Controller-Area-Network" class="headerlink" title="CAN总线协议(Controller Area Network)"></a>CAN总线协议(Controller Area Network)</h4><p>CAN总线协议是由博世开发的一种基于消息广播模式的串行通信总线，该协议非常适合于现场控制领域，主要用于实现汽车ECU之间的可靠通信。该通讯协议最高速率可达到1Mbps, 容错能力强。CAN控制器包含强大的检错和处理机制。另外CAN的节点之间不会传输大数据块，一帧CAN消息最多传输8字节用户数据。</p>
<p><strong>总线特点</strong></p>
<ul>
<li><strong>多主控制</strong>，总线空闲时所有单元都可以发送消息，最先访问总线的单元获得发送权，多个单元同时发送时，发送优先级高的可以发送。发送的消息保温不包含原地址和目标地址，只通过标识符表示消息的功能和优先级。</li>
<li><strong>总线为事件触发型</strong>，只有消息要发送时，节点才向总线上广播消息; 同时每个节点也可以通过发送远程帧请求其他节点发送数据。</li>
<li><strong>总线上可同时连接多个节点</strong>，可连接节点总数在理论上是没有限制的，实际可连接的节点数受总线上的时间延迟和电气负载限制。</li>
<li><strong>符合OSI通信系统参考模型</strong>，属于物理层和数据链路层。两线式总线结构，电气信号为差分式，通信介质可以采用双绞线，同轴电缆和光导纤维，一般采用双绞线。</li>
<li><strong>总线电平</strong>：显性(Dominant): 0, 隐性(Recessive): 1, CAN总线的信号电平具有线与特性，即显性电平0总是会掩盖隐性电平1，如果不同的节点同时发送显性和隐性电平，总线总是表现出显性电平。只有所有节点发送隐性电平是，总线才表现为隐性。<strong>线与特性是CAN总线仲裁机制的电路基础</strong>。</li>
<li><strong>高速CAN</strong>：总线通信速度最高1Mbp(40m条件下)。高速CAN时，CANH与CANL电压相同时为逻辑“1” (CANH&#x3D;CANL&#x3D;2.5V)。CANH和CANL电压相差2V时为逻辑“0” (CANH&#x3D;3.5V, CANL&#x3D;1.5V)。高速CAN收发器在共模电压范围内(-12V~12V),将CANH和CANL电压差大于0.9V成为显性状态，将CANH和CANL电压差小于0.5定义为隐性状态。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/917884/201906/917884-20190629175927325-911993050.png" alt="高速CAN信号电平（ ISO 11898-2）"></p>
<ul>
<li><strong>低速CAN</strong>：定义CANH和CANL电压相差 5V （CANH &#x3D; 0V, CANL &#x3D; 5V）时为逻辑“1”，相差 2.2V （CANH &#x3D; 3.6V, CANL &#x3D; 1.4V）时为逻辑“0”。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/917884/201906/917884-20190629180018330-1726697444.png" alt="低速CAN信号电平（ ISO 11898-3）"></p>
<p><strong>CAN报文帧结构</strong>：在CAN总线上，报文以“帧”的形式发送，每个报文帧包含以下部分：</p>
<ul>
<li>帧起始：总线空闲时为隐性状态，帧起始由单个显性位构成，标志报文开始，在总线上起同步作用。</li>
<li>仲裁段：仲裁段由报文的标识符完成，即ID，标准CAN的标识符为11位，扩展CAN中为29位。</li>
<li>控制段：主要定义了数据域的字节长度，通过数据长度码，接收节点可以判断报文数据是否完整。</li>
<li>数据域：主要包含0~8个字节数据。</li>
<li>CRC域：循环冗余码校验</li>
<li>帧结束：由一串七个隐性位组成，表示报文帧的结束。</li>
</ul>
<p><strong>CAN报文帧种类</strong></p>
<p>（1）数据帧：由发送节点发出，包含0 - 8个数据字节。</p>
<p>（2）远程帧：发送远程帧向网络节点请求发送某一标识符的数据帧。</p>
<p>（3）错误帧：总线节点发现错误时，以错误帧的方式通知网络上的其他节点。</p>
<p>（4）过载帧：发送过载帧，表示当前节点不能处理后续的报文（如帧延迟等）。</p>
<h4 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h4><p>SPI(Serial Peripheral interface)串行外围设备接口，该接口主要用在EEPROM，Flash，实时时钟，AD转化器，数字信号处理器和数字信号解码器之间。</p>
<ul>
<li>该协议是一种高速的，<strong>全双工同步串行</strong>通信总线。</li>
<li>没有速度限制，一般可达到10Mbps。</li>
<li>主要有四根线：MOSI， MISO，SCLK，CS(片选，选择从设备)。数据在上升下降沿改变。</li>
<li>优点：全双工通信，简单，传输速率快</li>
<li>缺点：没有指定的流控制，没有应答机制确认是否收到数据，相对IIC可靠性不高。</li>
</ul>
<ol>
<li>SPI的四种模式：<br>SPI有四种工作模式，SPI为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟的极性(CPOL)和时钟相位(CPHA)可以进行配置。CPOL决定SPI空闲时，时钟信号的电平。CPHA决定SPI在SCLK的第几个边沿开始采样数据。</li>
</ol>
<ul>
<li>CPOL&#x3D;0：串行同步时钟的空闲状态是低电平</li>
<li>CPOL&#x3D;1：串行同步时钟的空闲状态是高电平</li>
<li>CPHA&#x3D;0：SPI在串行同步时钟的第一个跳边沿开始采样</li>
<li>CPHA&#x3D;1：SPI在串行同步时钟的第二个跳边沿开始采样</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>DMA(Direct Memory Access),即直接存储器访问，DMA的传输方式可以无需CPU直接进行控制传输，也没有中断处理方式那样的保护现场和恢复现场的过程。通过硬件为RAM与I&#x2F;O设备开辟一条直接传输数据的通路，可以使CPU的效率大为提高。</p>
<ul>
<li>作用： 用于内存和内存之间或内存和外设之间的高速数据传输。</li>
</ul>
<ol>
<li><strong>DMA传输包括哪些操作？</strong>(STM32为例)<br> 每一次DMA传输包括三个操作<ul>
<li>通过DMA的寄存器寻址，从外设数据寄存器或存储器单元加载数据。</li>
<li>DMA计数器在数据存储结束后递减，该计算器中包含仍需执行的事务数目。</li>
</ul>
</li>
</ol>
<p>产生事件后，外设会向DMA控制器发送请求信号，DMA控制器根据通道优先级处理该请求，只要DMA控制器访问外设，DMA控制器就会向外设发送确认信号，外设获得确认信号后，便会立即释放请求。一旦外设使请求失效，DMA就会释放确认信号。如果有更多的请求，外设可以启动下一个事务。</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="Static关键字作用"><a href="#Static关键字作用" class="headerlink" title="Static关键字作用"></a>Static关键字作用</h3><h3 id="Const关键字作用"><a href="#Const关键字作用" class="headerlink" title="Const关键字作用"></a>Const关键字作用</h3><h3 id="Voilatile关键字作用"><a href="#Voilatile关键字作用" class="headerlink" title="Voilatile关键字作用"></a>Voilatile关键字作用</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T16:00:00.000Z" title="5/1/2021, 12:00:00 AM">2021-05-01</time>发表</span><span class="level-item"><time dateTime="2021-05-11T05:39:22.000Z" title="5/11/2021, 1:39:22 PM">2021-05-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 分钟读完 (大约2376个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/01/work/001.c_basic/">C语言基础-嵌入式面试</a></h1><div class="content"><h3 id="1-C和C-区别："><a href="#1-C和C-区别：" class="headerlink" title="1. C和C++区别："></a>1. C和C++区别：</h3><ul>
<li>C语言：面向过程的语言，其核心关注于问题是如何被解决的，把实现一个软件功能的过程分为一个个过程。 例如汽车要去加油，其过程为：汽车启动-&gt;汽车行驶-&gt;汽车加油。在这里我们不关注物件本身(汽车这个对象)，默认定义执行该过程的主题是汽车。</li>
<li>C++语言： 面向对象的语言，在计算机科学中的对象既可以表示客观世界的问题空间(namespace)中的具体的某个事物，又可以表示软件系统解空间的基本元素，如变量、数据结构、函数等。例如汽车要去加油，汽车&lt;启动，开车，加油&gt;, 我们关注物件(对象)本身，只需要考虑什么时间干什么事。启动，开车，加油属于这个物件的基本属性。</li>
</ul>
<h2 id="C语言基础部分："><a href="#C语言基础部分：" class="headerlink" title="C语言基础部分："></a>C语言基础部分：</h2><ul>
<li><strong>标识符：</strong> 一个标识符以字母或者下划线开始的后面可以跟多个字母、数字、下划线。C标识符中不允许出现标点字符，并且区分大小写。</li>
<li><strong>关键字：</strong> C中的保留字，这些保留字不能作为常量名，变量名和其他标识符的名称。常用的的关键字包括:while, do, for, break, continue, default, goto, char, double, int, long, short, float,</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量可以被const修饰，那么它的值就不能被在改变</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td align="left">extern</td>
<td align="left"><strong>声明变量</strong>或函数是在其他文件或本文件其他位置定义</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度(即所占的字节数)</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td align="left">typeof</td>
<td align="left">给数据类型取别名</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">声明函数无返回值或者无参数，<strong>声明无类型指针</strong></td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可以被隐含的改变</td>
</tr>
</tbody></table>
<ul>
<li>**数据类型： ** C语言有四种数据类型：<ul>
<li>**基本数据类型: **他们是算术类型，包括整数类型和浮点类型，注意char是属于整数类型的。 基本数据类型占用的空间(64位机器)：char-1字节，int-4字节， float-4字节，double-8字节。</li>
<li><strong>枚举类型：</strong> 他们也是算术类型，被用来定义在程序中，只能赋予其一定的离散整数值的变量</li>
<li><strong>void类型：</strong> 类型说明符 void表明没有可用的值</li>
<li><strong>派生类型：</strong> 它们主要包括：指针，数组，结构，共用体，和函数类型</li>
<li><strong>强制类型转换：</strong> (类型说明符)(表达式)</li>
</ul>
</li>
</ul>
<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a><strong>变量：</strong></h4><p>变量是程序可操作的存储区名称。<strong>全局变量</strong>保存在内存的全局存储区中，占用静态的存储单元；<strong>局部变量</strong>保存在栈中，只有在所在函数被调用的时候才动态地为变量分配存储单元。</p>
<p><strong>C语言经过编译后将内存分为一下几个区域：</strong></p>
<ul>
<li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程的各种参数，局部变量，返回值以及函数的返回地址。操作方式类似于数据中的栈。</li>
<li>堆(heap): 用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则在程序结束后由系统自动回收。注意：这里的对并不是数据结构中的堆。</li>
<li>全局(静态)存储区: 分为DATA和BSS段，DATA段(全局初始化区)存放初始化的全局变量和静态变量；BSS段(全局未初始化分区) 存放未初始化的全局变量和静态变量。程序运行结束时自动释放，其中在BSS段在程序执行之前会被系统自动清零，所以未初始化的全局变量和静态变量在程序执行之前已经为0.</li>
<li>文字常量区：存放常量字符串，程序结束由系统释放。</li>
<li>程序代码区：存放程序的二进制代码。</li>
</ul>
<p>因此，C语言的全局变量和局部变量在内存之中是有区别的，C语言的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在的函数被调用时才有系统动态在栈中分配临时性的存储单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int k1 = 1;</span><br><span class="line">int k2;</span><br><span class="line">static int k3 = 2;</span><br><span class="line">static int k4;</span><br><span class="line">int main( )</span><br><span class="line">&#123;  staticint m1=2, m2;</span><br><span class="line">    inti=1;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[10] = &quot;hello&quot;;</span><br><span class="line">    char*q = &quot;hello&quot;;</span><br><span class="line">    p= (char *)malloc( 100 );</span><br><span class="line">    free(p);</span><br><span class="line">    printf(&quot;栈区-变量地址  i：%p\n&quot;, &amp;i);</span><br><span class="line">    printf(&quot;                p：%p\n&quot;, &amp;p);</span><br><span class="line">    printf(&quot;              str：%p\n&quot;, str);</span><br><span class="line">    printf(&quot;                q：%p\n&quot;, &amp;q);</span><br><span class="line">    printf(&quot;堆区地址-动态申请：%p\n&quot;, p);</span><br><span class="line">    printf(&quot;全局外部有初值 k1：%p\n&quot;, &amp;k1);</span><br><span class="line">    printf(&quot;    外部无初值 k2：%p\n&quot;, &amp;k2);</span><br><span class="line">    printf(&quot;静态外部有初值 k3：%p\n&quot;, &amp;k3);</span><br><span class="line">    printf(&quot;    外静无初值 k4：%p\n&quot;, &amp;k4);</span><br><span class="line">    printf(&quot;  内静态有初值 m1：%p\n&quot;, &amp;m1);</span><br><span class="line">    printf(&quot;  内静态无初值 m2：%p\n&quot;, &amp;m2);</span><br><span class="line">    printf(&quot;文字常量地址    ：%p, %s\n&quot;,q, q);</span><br><span class="line">    printf(&quot;程序区地址      ：%p\n&quot;,&amp;main);</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量是固定值，在程序的执行期间不会改变。它可以是任意基本的数据类型，整数常量，浮点常量，字符常量，枚举常量等。</p>
<ul>
<li><strong>定义常量：</strong> 定义常量有两种方法，使用#define或者使用const关键字，这两种方法从本质上是不同的。#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！<br> <img src="https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15.png"><br>示例<br>  #define length 10<br>  #define NEWLINE ‘\n’<br><br>  const int var&#x3D;5;</li>
<li>整数常量：整数常量可以是十进制，八进制，十六进制的常量，前缀指定基数，0x&#x2F;0X表示十六进制，0表示八进制，不带前缀默认代表十进制。<strong>整数常量也可以带一个后缀，U代表无符号整数, L代表长整数，大小写和顺序任意。</strong></li>
</ul>
<h3 id="C-语言的三大特性"><a href="#C-语言的三大特性" class="headerlink" title="C++语言的三大特性"></a>C++语言的三大特性</h3><ul>
<li><strong>封装：</strong> C++语言支持数据封装，类是数据封装的工具，对象是数据封装的实现，在封装中，还提供一种对数据访问控制的机制，是的一些数据隐藏在封装体内，具有隐藏性。封装和外接的信息交换是通过操作接口进行的，这种访问的控制机制体现在类的共有成员(public)，私有成员(private)，和保护成员(protected)上。私有成员只有类内说明的一些函数才能访问；共有成员类外的函数也可以访问，保护成员只有该类的成员函数和派生类才能访问。</li>
<li><strong>继承：</strong> C++语言允许单继承和多继承。一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类可以继承基类的成员同时也可以定义自己的成员。继承是实现数据抽象和共享的一种机制。该机制可以避免不能重复利用程序导致的资源浪费。</li>
<li><strong>多态：</strong> 多态指的是对不同类发出的相同消息会有不同的实现。多态性也可以理解为，在一般类中定义的属性和服务被特殊类继承后，可以具有不同的数据类型或不同的实现。简单来说，多态性指的是发出同样的消息被不同的数据类型的对象接收后会导致不同的行为。C++支持多态性主要表现在：C++语言允许函数重载和运算符重载；C++语言通过定义虚函数来支持动态联编。多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-30T16:00:00.000Z" title="5/1/2021, 12:00:00 AM">2021-05-01</time>发表</span><span class="level-item"><time dateTime="2022-03-24T15:25:39.679Z" title="3/24/2022, 11:25:39 PM">2022-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">18 分钟读完 (大约2733个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/01/work/003.Autosar/">Autosar学习</a></h1><div class="content"><h3 id="应用软件层AppL"><a href="#应用软件层AppL" class="headerlink" title="应用软件层AppL"></a>应用软件层AppL</h3><p>应用软件层最重要的就是SWC, 而SWC之间的通信需要接口，每个SWC由runnable组成，所以应用软件层的组成主要分为三个部分：</p>
<ul>
<li>应用软件组件(SWC)</li>
<li>AutoSAR的接口(Ports)和连接器(Connector)</li>
<li>可运行实体(Runnable)<br><img src="https://img-blog.csdnimg.cn/20190722153832837.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></li>
</ul>
<p><strong>例子：汽车顶灯控制</strong><br>汽车的顶灯一般有三种模式：常闭，常开，随着车的开关而开关的模式。实现汽车顶灯的控制需要传感器，处理单元和执行器。假设左右两个车门，左右两个车灯，一个开关传感器。该车顶的的控制需要7个SWC实现。但是这些SWC并非由一个ECU完成。<br><img src="https://img-blog.csdnimg.cn/20190719094849718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>SWC之间的通信是通过虚拟功能总线(VFB)实现，该总线是片内外通信的结合体：</p>
<ul>
<li>在片内通过RTE通信。每个SWC可以理解为一个.c文件，C文件之间的通信通过全局变量进行。</li>
<li>在片外通过片外的总线进行通信。常用的就是CAN总线。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190719101705190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>在实际的汽车中，上述的7个SWC将被分配到两个ECU中。车灯开关，调光控制器和左右顶灯由车身顶部的ECU控制；左右车门和车门开关逻辑单元由专用的车门ECU芯片控制。两个ECU即连个控制器，分别位于车身前部的车门控制器和车身顶部的顶灯控制器。ECU内部通信通过RTE进行管理，跨ECU通信通过外部CAN总线进行。</p>
<p><img src="https://img-blog.csdnimg.cn/2019071911270359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<h4 id="SWC的类型"><a href="#SWC的类型" class="headerlink" title="SWC的类型"></a>SWC的类型</h4><p>SWC的类型总共有三种：原子级SWC(Atomic SWC)，集合级SWC(Composition SWC)，特殊的SWC。<br>原子级SWC(Atomic SWC): 最小单元，不可再拆分，每个原子级SWC对应一个.c文件。比其更小的单元是runnable，即.c文件中的函数。每个SWC的功能基本上都是用来实现特定的算法。</p>
<p><img src="https://img-blog.csdnimg.cn/20190719142821333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70" alt="Atomic SWC"></p>
<p>集合级SWC(Composition SWC)：该级别的SWC将很多功能相近或者需要整合到一处的Atomic SWC整合起来，方便SWC归类。</p>
<p><img src="https://img-blog.csdnimg.cn/20200804205737527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>集合级SWC类似于一个文件夹，用于存放相近功能的Atomic SWC.</p>
<p><img src="https://img-blog.csdnimg.cn/20190719145056408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>特殊SWC：在实际的工程中，不止应用层需要设计SWC, 在基础软件层中，IO硬件抽象成层和复杂驱动(CDD)都需要手动添加代码。他们被看做一种特殊的SWC进行操作。</p>
<p><img src="https://img-blog.csdnimg.cn/2019071915062451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<h4 id="接口-Ports-的类型"><a href="#接口-Ports-的类型" class="headerlink" title="接口(Ports)的类型"></a>接口(Ports)的类型</h4><p>Ports存在于SWC之间作为通信的通道。或者SWC通过RTE和BSW做接口通信使用。Ports共有五种类型，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190720093102710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>S&#x2F;R接口：用于传输数据。该数据传输过程通过RTE进行管理，避免数据出错。如同时调用同一数据可能出错。在数据传输时，一个接口可以包含多个数据，类似于通过结构体的传输。可以传输的数据类型包括基础的如int, float等，以及复杂数据类型如record, array等。</p>
<p><img src="https://img-blog.csdnimg.cn/20190720103911283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>C&#x2F;S接口：该接口的作用是提供操作，即Server提供函数供Client调用。调用的过程分为同步，异步两种。同步代表直接调用，相当于函数直接插入上下文运行；异步需要灯带，相当于函数在另一个线程中运行，不影响原线程运行。C&#x2F;S接口的可以提供多个操作(函数)，可在ECU内部或者跨ECU调用。</p>
<p><img src="https://img-blog.csdnimg.cn/20190720100501545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<h4 id="可运行实体-Runnable"><a href="#可运行实体-Runnable" class="headerlink" title="可运行实体(Runnable)"></a>可运行实体(Runnable)</h4><p>Runnable即SWC中的函数，在AutoSAR架构被DaVinci软件生成时，Runnable是空函数，需要手动添加代码实现相应功能。Runnable可以被触发，例如定时器触发，操作调用触发，以及接受数据触发等。</p>
<p><img src="https://img-blog.csdnimg.cn/20190720112947908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<h3 id="实时运行环境-RTE"><a href="#实时运行环境-RTE" class="headerlink" title="实时运行环境(RTE)"></a>实时运行环境(RTE)</h3><p>RTE是AutoSAR架构中介于应用层和基础软件层之间，是AutoSAR虚拟功能总线VFB的接口的实现。其目的是为应用软件的SWC之间的通信提供基础设施服务，并促进包括OS在内的基础软件组建的访问。</p>
<p><img src="https://pic3.zhimg.com/80/v2-388609aa5ac84f590ea1e0f2326d352e_720w.jpg"></p>
<p>RTE在Vector的工具链中是自动生成的，它的作用包括：</p>
<ul>
<li>提供ECU内部或者跨ECU的通信管理，通过VFB, RTE就是VFB的具体实现。</li>
<li>提供对Runnable的管理功能，包括触发，唤醒等。即RTE可以把Runnable配置到OS对应的Task中去，生成的Task代码通过RTE的时间触发runnables的运行。注意这里RTE抽象了OS，防止SWC直接访问OS和BSW。</li>
</ul>
<p>下图是车顶的控制系统中SWC与RTE以及BSW的组件之间的关系。<br><img src="https://img-blog.csdnimg.cn/20190724120846120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<h4 id="RTE对Runnables的运行支撑"><a href="#RTE对Runnables的运行支撑" class="headerlink" title="RTE对Runnables的运行支撑"></a>RTE对Runnables的运行支撑</h4><p>RTE作为运行环境的主要功能有：</p>
<ul>
<li>通过RTE给runnables提供触发时间</li>
<li>通过RTE给runnables提供所需的资源</li>
<li>将BSW和SWC做隔绝：即runnables的运行条件由RTE提供，不能由OS直接提供。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200108121119825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p><strong>Runnables的触发条件</strong><br>Runnables在设计时，需要考虑触发条件，负责无法运行。触发条件即一些特定的事件。AutoSAR中主要规定了以下触发事件：</p>
<ul>
<li>初始化事件：初始化自动触发</li>
<li>定时器事件：给定一个周期性定时器，计时完成自动触发</li>
<li>接受数据事件(S&#x2F;R): Receiver Ports接受数据即可触发</li>
<li>接受数据错误事件</li>
<li>数据发送完成事件：Send Ports发送完成即可触发</li>
<li>操作调用事件(C&#x2F;S)：</li>
<li>模式切换事件</li>
<li>模式切换应答事件</li>
<li>异步服务返回事件：C&#x2F;S可在异步下运行，即在异步调用Server函数时，被调用函数作为一个线程与当前程序并行运行，运行结束后返回时，将会触发异步服务返回事件。</li>
</ul>
<h4 id="RTE对Ports的支持"><a href="#RTE对Ports的支持" class="headerlink" title="RTE对Ports的支持"></a>RTE对Ports的支持</h4><p>RTE可以作为SWCs和BSW之间的交流途径：</p>
<ul>
<li>作为VFB的具体实现</li>
<li>作为S&#x2F;R接口的通信实现</li>
<li>作为C&#x2F;S接口的通信实现</li>
<li>ECU内部通信&#x2F;跨ECU通过COM口通信</li>
<li>实现AR-COM的回调功能，具体实现是在SWC中完成的，RTE负责完成这个回调机制<br>其他特征：</li>
<li>RTE提供了一种实现<strong>数据一致性</strong>的机制，即避免多个SWC同时操作一个数据出现问题。</li>
<li>RTE支持简单和复杂的数据类型</li>
<li>对SWC的类型进行实例化</li>
</ul>
<p><strong>R&#x2F;S接口的实现</strong><br>在配置好DaVinci后，RTE会自动生成一些调用，在runnable上方，可以直接复制。下面是一个例子：</p>
<pre><code>/**********************************************************************************************************************
 *
 * Runnable Entity Name: RAB_Core0_100us
 *
 *---------------------------------------------------------------------------------------------------------------------
 *
 * Executed if at least one of the following trigger conditions occurred:
 *   - triggered on TimingEvent every 100us
 *
 **********************************************************************************************************************
 *
 * Input Interfaces:
 * =================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Read_AppPI_Can_ReceiverCore0_DEP_Can_Receiver(Idt_Can_Receiver *data)
 *
 * Output Interfaces:
 * ==================
 *   Explicit S/R API:
 *   -----------------
 *   Std_ReturnType Rte_Write_AppPI_Can_SenderCore0_DEP_Can_Sender(Idt_Can_Sender data, Rte_TransformerError *transformerError)
 *
 * Service Calls:
 * ==============
 *   Service Invocation:
 *   -------------------
 *   Std_ReturnType Rte_Call_ComM_UserRequest_GetCurrentComMode(ComM_ModeType *ComMode)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_ComM_UserRequest_E_NOT_OK
 *   Std_ReturnType Rte_Call_ComM_UserRequest_GetMaxComMode(ComM_ModeType *ComMode)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_ComM_UserRequest_E_NOT_OK
 *   Std_ReturnType Rte_Call_ComM_UserRequest_GetRequestedComMode(ComM_ModeType *ComMode)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_ComM_UserRequest_E_NOT_OK
 *   Std_ReturnType Rte_Call_ComM_UserRequest_RequestComMode(ComM_ModeType ComMode)
 *     Synchronous Service Invocation. Timeout: None
 *     Returned Application Errors: RTE_E_ComM_UserRequest_E_MODE_LIMITATION, RTE_E_ComM_UserRequest_E_NOT_OK
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 * DO NOT CHANGE THIS COMMENT!           &lt;&lt; Start of documentation area &gt;&gt;                  DO NOT CHANGE THIS COMMENT!
 * Symbol: RAB_Core0_100us_doc
 *********************************************************************************************************************/
</code></pre>
<p>​<br>​    &#x2F;**********************************************************************************************************************<br>​     * DO NOT CHANGE THIS COMMENT!           &lt;&lt; End of documentation area &gt;&gt;                    DO NOT CHANGE THIS COMMENT!<br>​     <em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>&#x2F;<br>​<br>    FUNC(void, SWCCore0Basic_Type_CODE) RAB_Core0_100us(void) &#x2F;* PRQA S 0850 <em>&#x2F; &#x2F;</em> MD_MSR_19.8 *&#x2F;<br>    {<br>    &#x2F;</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>*<br>     * DO NOT CHANGE THIS COMMENT!           &lt;&lt; Start of runnable implementation &gt;&gt;             DO NOT CHANGE THIS COMMENT!<br>     * Symbol: RAB_Core0_100us<br>     *********************************************************************************************************************&#x2F;</p>
<p>​<br>​    &#x2F;**********************************************************************************************************************<br>​     * DO NOT CHANGE THIS COMMENT!           &lt;&lt; End of runnable implementation &gt;&gt;               DO NOT CHANGE THIS COMMENT!<br>​     *********************************************************************************************************************&#x2F;<br>​    }</p>
<p><strong>直接调用：</strong> 相当于有一个全局变量，runnable可以直接读写这个变量。<br><img src="https://img-blog.csdnimg.cn/20190730105317253.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"><br>其写法采用一下语法：(<data>指的是全局变量的名字，data指的是局部变量。这些函数都是在runnable中使用的)</p>
<pre><code>Std_ReturnType Rte_Read_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; *data)
Std_ReturnType Rte_Write_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; data)
</code></pre>
<p><strong>缓存调用：</strong> 该调用方式相当于先将全局变量复制到一个runnable的局部变量中，然后对局部变量进行操作，最后把这个局部变量赋值到全局变量中。</p>
<p><img src="https://img-blog.csdnimg.cn/20190730110555796.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h5ZnhfZmh3,size_16,color_FFFFFF,t_70"></p>
<p>使用方法：</p>
<pre><code>&lt;DataType&gt; Rte_IRead_&lt;r&gt;_&lt;port&gt;_&lt;data&gt; (void)
void Rte_IWrite_&lt;r&gt;_&lt;port&gt;_&lt;data&gt; (&lt;DataType&gt; data)
</code></pre>
<p><strong>队列调用：</strong> </p>
<h4 id="RTE数据一致性的实现"><a href="#RTE数据一致性的实现" class="headerlink" title="RTE数据一致性的实现"></a>RTE数据一致性的实现</h4><h4 id="RTE对Interface的支持"><a href="#RTE对Interface的支持" class="headerlink" title="RTE对Interface的支持"></a>RTE对Interface的支持</h4><h3 id="基础软件层-BSW"><a href="#基础软件层-BSW" class="headerlink" title="基础软件层(BSW)"></a>基础软件层(BSW)</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-05T16:00:00.000Z" title="2/6/2021, 12:00:00 AM">2021-02-06</time>发表</span><span class="level-item"><time dateTime="2021-02-06T19:28:24.000Z" title="2/7/2021, 3:28:24 AM">2021-02-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">几秒读完 (大约82个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/06/Algorithm/003.vector_cplusplus/">C++：vector容器</a></h1><div class="content"><h3 id="二维向量的遍历方法"><a href="#二维向量的遍历方法" class="headerlink" title="二维向量的遍历方法"></a>二维向量的遍历方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//二维向量的遍历，迭代器遍历</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; array = &#123;&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;&#125;;  </span><br><span class="line">vector&lt;vector&lt;int &gt;&gt;::iterator iter;</span><br><span class="line">for (iter = array.begin(); iter != array.end() ; ++iter) &#123;</span><br><span class="line">    for (int i = 0; i &lt; (*iter).size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; (*iter)[i] &lt;&lt; &quot; &quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//二维向量的遍历，数组下表</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; array = &#123;&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;&#125;;  </span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; array.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j = 0; j &lt; array[i].size(); j++)</span><br><span class="line">        cout &lt;&lt; V[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-24T16:00:00.000Z" title="1/25/2021, 12:00:00 AM">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-25T18:18:04.000Z" title="1/26/2021, 2:18:04 AM">2021-01-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">2 分钟读完 (大约225个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/25/Algorithm/001.is_prime/">算法：判断质数</a></h1><div class="content"><p>质数定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。</p>
<h3 id="思路1：定义"><a href="#思路1：定义" class="headerlink" title="思路1：定义"></a>思路1：定义</h3><p>根据定义，采用2到n-1中的每一个数去除n，如果不能被整除，则该数为质数。时间复杂度：O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool isprime = true;</span><br><span class="line">    for(int i=2; i &lt; n; i++)&#123;</span><br><span class="line">        if(n % i==0)&#123;</span><br><span class="line">            isprime=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isprime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="思路2：质数筛选定理"><a href="#思路2：质数筛选定理" class="headerlink" title="思路2：质数筛选定理"></a>思路2：质数筛选定理</h3><p><strong>质数筛选定理：</strong> 如果n不能够被不大于根号n的任何质数整除，则n是一个质数。<br><strong>参考链接：</strong> </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100051075">https://zhuanlan.zhihu.com/p/100051075</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wo17fang/article/details/47656769">https://blog.csdn.net/wo17fang/article/details/47656769</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int n)&#123;</span><br><span class="line">    bool isprime= true;</span><br><span class="line">    int max = static_cast&lt;int&gt;(sqrt(n)); \\隐式类型转换</span><br><span class="line">    for(int j=2; j&lt;=max; j++)&#123;</span><br><span class="line">        if(n%j == 0)&#123;</span><br><span class="line">            isprime=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    return isprime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-24T16:00:00.000Z" title="1/25/2021, 12:00:00 AM">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-27T04:56:42.000Z" title="1/27/2021, 12:56:42 PM">2021-01-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">12 分钟读完 (大约1868个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/25/Algorithm/002.algorithm_sorting/">排序算法</a></h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>排序算法是程序设计中最基本的算法，常用的排序算法有十种，可以分为内部排序和外部排序两种类型：</p>
<h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><ul>
<li>内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。</li>
<li>常见的内部排序算法：冒泡排序，快速排序，插入排序，选择排序，希尔排序，堆排序。</li>
</ul>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><ul>
<li>外部排序是针对于极大量数据的排序算法，由于数据无法一次放入内存，算法采用“排序-归并” 策略，首先将部分数据依次读入内存，排序后生成有序的临时文件，在归并阶段将这些临时文件组成较大的有序文件。</li>
<li>常见的外部排序算法有归并排序，计数排序，桶排序，基数排序。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png"><br>关于排序算法的简单介绍：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png"></p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>如果两个具有相同键的对象在输入输出中的顺序与在输入未排序数组中出现的顺序相同，则该排序算法被认为是稳定的。有些排序算法本质上是稳定的，例如插入排序，合并排序，冒泡排序等。而有些排序算法则不是，例如堆排序，快速排序等。</p>
<p>但是，任何给定的不稳定算法都可以修改为稳定。可以使用特定的排序算法来使其稳定，但是通常，可以通过更改键比较操作将本质上不稳定的任何基于比较的排序算法修改为稳定，以便将两个键的比较视为位置。具有相同键的对象的系数。<a target="_blank" rel="noopener" href="http://www.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf">参考文献</a><br><img src="https://i1.wp.com/i.stack.imgur.com/alljt.png"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br><strong>算法步骤：</strong></p>
<ol>
<li>以升序为例，比较相邻两个元素大小，如果第一个元素大于第二个，则交换两个元素，否则不做改变。</li>
<li>从数组的第一个元素开始，遍历到数组的倒数第二个元素。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void bubble_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int i = 0; i &lt; len-1; i++)&#123;</span><br><span class="line">        for(int j = 0; j&lt;len-1-i; j++)&#123;</span><br><span class="line">            if(num[j] &gt; num[j+1]) </span><br><span class="line">                swap(num[j], num[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; num= &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;;</span><br><span class="line">    int len = num.size();</span><br><span class="line">    for(int i=0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    Bubble_sort(num, len);</span><br><span class="line">    for(int i=0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的方法为第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。<br><strong>算法步骤：</strong></p>
<ol>
<li>记录数据中的第一个元素的index</li>
<li>遍历数据并与该元素进行比较，如果小于该元素则更新index，完成遍历后交换第一个元素和index所指向的最小值。</li>
<li>重复以上步骤直至完成排序。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void selection_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    int min;</span><br><span class="line">    for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for(int j=i; j&lt;len; j++)&#123;</span><br><span class="line">            if(num[j] &lt; num[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void intersection_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int i=1; i&lt;len; i++)&#123;</span><br><span class="line">        for(int j=i; j&gt;0; j--)&#123;</span><br><span class="line">            if(num[j] &lt; num[j-1])</span><br><span class="line">                swap(num[j-1], num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br>希尔排序原理的视频介绍：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rE411g7rW?from=search&seid=7021456873332538636">希尔排序</a></li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int gap = len / 2; gap &gt; 0; gap /= 2)</span><br><span class="line">        for(int i = gap; i &lt; len; i++)&#123;</span><br><span class="line">            int temp = num[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for( ; j &gt;= gap &amp;&amp; temp &lt; num[j-gap]; j-=gap)</span><br><span class="line">                num[j] = num[j-gap];</span><br><span class="line">            num[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是在实践中最快的已知排序算法，算法的平均运行时间是O(NlogN), 最坏的性能为O(N^2).<br><strong>算法步骤：</strong></p>
<ol>
<li><p>从数列中随机挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif"></p>
<p>参考资料：<br>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/renyp8799/article/details/9329681?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">关于排序算法的一点知识——实例和伪代码</a><br>[2] </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-04-30T16:00:00.000Z" title="5/1/2020, 12:00:00 AM">2020-05-01</time>发表</span><span class="level-item"><time dateTime="2020-07-30T18:40:00.000Z" title="7/31/2020, 2:40:00 AM">2020-07-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">1 分钟读完 (大约201个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/01/Major/08.learn_pytorch/">pytorch学习</a></h1><div class="content"><h3 id="pytorch常用代码"><a href="#pytorch常用代码" class="headerlink" title="pytorch常用代码"></a>pytorch常用代码</h3><ul>
<li>在pytorch中使用tensorboard: <a target="_blank" rel="noopener" href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/">https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/</a></li>
<li>pytorch常用代码段合集： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59205847">https://zhuanlan.zhihu.com/p/59205847</a></li>
</ul>
<h3 id="pytorch踩坑记录"><a href="#pytorch踩坑记录" class="headerlink" title="pytorch踩坑记录"></a>pytorch踩坑记录</h3><ol>
<li>ERROR: Unexpected bus error encountered in worker. This might be caused by insufficient shared memory (shm)<ul>
<li>出现这个错误的情况是，在服务器上的docker中运行训练代码时，batch size设置得过大，shared memory不够（因为docker限制了shm）.解决方法是，将Dataloader的num_workers设置为0.</li>
<li>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59271905">https://zhuanlan.zhihu.com/p/59271905</a></li>
</ul>
</li>
<li>AttributeError: module ‘scipy.misc’ has no attribute ‘toimage’<ul>
<li><pre><code>解决方法：由于安装的scipy版本是1.4版本，该版本删除了toimage函数，最方便的解决办法降版本
</code></pre>
  $ pip uninstall scipy<br>  $ pip install scipy&#x3D;&#x3D;1.2.0</li>
</ul>
</li>
<li>ModuleNotFoundError: No module named ‘tkinter’<ul>
<li>在utils.py中添加以下代码：<br>  import matplotlib<br>  matplotlib.use(‘agg’)<br>  import matplotlib.pyplot as plt</li>
</ul>
</li>
</ol>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E6%9C%AF%E4%B8%9A/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/%E6%9C%AF%E4%B8%9A/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E6%9C%AF%E4%B8%9A/">1</a></li><li><a class="pagination-link" href="/categories/%E6%9C%AF%E4%B8%9A/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E6%9C%AF%E4%B8%9A/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%85%8E%E6%80%9D/"><span class="level-start"><span class="level-item">慎思</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%AF%E4%B8%9A/"><span class="level-start"><span class="level-item">术业</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%8E%A9%E7%89%A9/"><span class="level-start"><span class="level-item">玩物</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/03/04/Notebook/Linux/Linux_Bash/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gay01tguhxj30go07s3yj.jpg" alt="Linux Bash总结"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-03T16:00:00.000Z">2022-03-04</time></p><p class="title"><a href="/2022/03/04/Notebook/Linux/Linux_Bash/">Linux Bash总结</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/09/work/005.FreeRTOS/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="FreeRTOS学习笔记02"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-08T16:00:00.000Z">2021-05-09</time></p><p class="title"><a href="/2021/05/09/work/005.FreeRTOS/">FreeRTOS学习笔记02</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/07/work/004.RTOS/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="FreeRTOS学习笔记01"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-06T16:00:00.000Z">2021-05-07</time></p><p class="title"><a href="/2021/05/07/work/004.RTOS/">FreeRTOS学习笔记01</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/03/work/Emmbed_system_QA/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="嵌入式面试常见问题整理"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-02T16:00:00.000Z">2021-05-03</time></p><p class="title"><a href="/2021/05/03/work/Emmbed_system_QA/">嵌入式面试常见问题整理</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-30T16:00:00.000Z">2021-05-01</time></p><p class="title"><a href="/2021/05/01/work/001.c_basic/">C语言基础-嵌入式面试</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Apollo/"><span class="tag">Apollo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Blogs/"><span class="tag">Blogs</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CV/"><span class="tag">CV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Self-driving/"><span class="tag">Self-driving</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tensorflow/"><span class="tag">Tensorflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nvidia/"><span class="tag">nvidia</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/object-detection/"><span class="tag">object detection</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/photo/"><span class="tag">photo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/point-cloud/"><span class="tag">point cloud</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pytorch/"><span class="tag">pytorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BB%BA%E6%A8%A1/"><span class="tag">建模</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%B7%E5%9B%BD%E9%A9%BE%E7%85%A7/"><span class="tag">德国驾照</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%88%AA%E6%8B%8D/"><span class="tag">航拍</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2022 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>