<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: 术业 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">术业</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-08T16:00:00.000Z" title="5/9/2021, 12:00:00 AM">2021-05-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-05-10T01:50:06.000Z" title="5/10/2021, 9:50:06 AM">2021-05-10</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 minutes read (About 2360 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/09/work/005.FreeRTOS/">FreeRTOS学习笔记02</a></h1><div class="content"><h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><p><strong>FreeRTOS</strong>是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需要。</p>
<p>FreeRTOS是为小型嵌入式系统设计的可裁剪实时内核。其主要特点有：</p>
<ul>
<li>调度器支持抢占式调度，协助式调度，或者两者混合。时间片可选</li>
<li>占用空间小，简单，易用</li>
</ul>
<h3 id="FreeRTOS的源码结构"><a href="#FreeRTOS的源码结构" class="headerlink" title="FreeRTOS的源码结构"></a>FreeRTOS的源码结构</h3><p>在FreeRTOS v9.0版本中，FreeRTOS的代码主要包含两个文件夹：FreeRTOS_CORE和FreeRTOS_PORTABLE。这两个文件夹下包含多个.C文件。</p>
<ul>
<li>port.c: 针对不同硬件平台的接口，定义与硬件接口相关的代码</li>
<li>heap_4.c： 内存管理相关</li>
<li>croutine.c：协程相关</li>
<li>event_groups.c：事件标志组相关</li>
<li>list.c：管理系统实际会应用到list，是FreeRTOS的一种基础数据结构</li>
<li>tasks.c：任务创建、挂起、恢复、调度相关</li>
<li>timers.c：软件定时器相关</li>
<li>queue.c：管理tasks之间的通信(message queue的概念)</li>
<li>FreeRTOSConfig.h：宏定义，配置RTOS所需要的资源</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/AndreLYL/BlogPictures/blog_files/img/20210508182833.png"></p>
<h3 id="FreeRTOS的任务间通信机制"><a href="#FreeRTOS的任务间通信机制" class="headerlink" title="FreeRTOS的任务间通信机制"></a>FreeRTOS的任务间通信机制</h3><p>裸机编程中，一个复杂的功能通常需要多个子函数来实现，不同的子函数之间的通常采用一些全局变量来实现联系。在RTOS中，我们不仅可以使用全局变量，还可以采用系统自带的任务间通信机制。这种机制更加受推荐。其原因是：</p>
<ol>
<li>阻塞等待机制比轮询等待更加高效：全局变量当用作某种事件的标志是，获取该标志的任务需要轮询检测标志位的状态是否变化。这样会产生大量的无效判断。如果使用任务间通信阻塞等待的机制，CPU可以转而处理其他事情，当标志变化时解除阻塞。又可以及时执行后续的处理。</li>
<li>全局变量会产生不可重入函数导致逻辑混乱：RTOS运行时，CPU需要调用不同的函数，如果全局变量使用不恰当，会导致原本设计的逻辑产生混乱。比如某个低优先级任务正在访问某个公共函数，并对函数中的全局变量进行了修改。还未退出函数时，更高优先级的任务抢占了CPU的使用权，并对该函数的全局变量进行了修改。此时低优先级任务若认为自己修改变量成功，执行后续逻辑时，就会发生错误。</li>
</ol>
<p>FreeRTOS任务间的通信方式：</p>
<ul>
<li>信号量(Semaphore): 用于任务间的同步，一个任务以阻塞方式灯带另一个任务释放信号量。</li>
<li>互斥量(Mutex)：用于任务间共享资源的互斥访问，使用前获取锁，使用后释放锁。</li>
<li>事件标志组(EventGroup): 用于任务间的同步，相比信号量，事件标志组可以等待多个事件的发生。</li>
<li>消息队列(Queue): 类比全局数据，它可以一次发送多个数据(一般将数据定义成结构体发送)，每次数据的大小固定不变。</li>
<li>流缓冲区(SteamBuffer)：在队列的基础上，优化的一种更加适合的数据结构，可以一次写入任意数量的字节，并且可以一次读取任意数量的字节。</li>
<li>消息缓冲区(MessageBuffer)：在流式缓冲区的基础上实现的，可以对消息进行设计改进。每一条消息的写入增加了一个字节用来表示该消息的长度，读取时需要至少一次性读出一条消息，否则会返回0.</li>
<li>任务通知(Notify): 不同于上面的任务通信方式(使用某种通信对象，通信对象是独立于任务的实体，有单独的存储空间，可以实现数据的传递和较复杂的同步，互斥功能)， 通知是发向一个指定的任务的，直接改变该任务 TCB的某些变量。</li>
</ul>
<h3 id="FreeRTOS队列"><a href="#FreeRTOS队列" class="headerlink" title="FreeRTOS队列"></a>FreeRTOS队列</h3><p>在实际应用中，一个任务或中断服务函数经常需要和另一个任务进行消息传递。裸机情况下通常通过全局变量实现。但是操作系统使用全局变量的方式会涉及“资源管理”问题。<strong>FreeRTOS中采用队列机制完成任务与任务，和任务与中断之间的消息传递。</strong> 队列可以存储有限的，大小固定的数据项目。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>FreeRTOS创建任务、队列、信号量有两种方法：</p>
<p>第一种是<strong>由用户自行定义所需的RAM</strong>，这种方法也叫静态的方法。静态方法的函数一般由Static结尾，比如任务创建 <code>xTaskCreateStatic()</code>。 使用此函数创建任务的时候需要用户定义任务堆栈。</p>
<p>另一种是<strong>动态的申请所需的RAM</strong>，使用动态内存管理时，FreeRTOS内核在创建任务、队列、信号量的时候会动态的申请RAM。C语言标准库的malloc()和free()也可以实现动态内存管理，但这种方法在小型嵌入式系统中效率不高，会占用很多代码空间，并且他们的线程不是安全的，程序执行的时间也是不确定的，此外还会导致内存碎片。因此在FreeRTOS中，内核采用 <code>pvPortMalloc()</code>代替 <code>malloc()</code> 申请内存，采用 <code>vPortFree()</code>函数释放内存。<strong>关于内存分配，FreeRTOS提供了5这种内存分配的方法：</strong> 也就是在5个.c文件，heap_1.c, heap_2.c, heap_3.c, heap_4.c, heap_5.c。</p>
<p><strong>内存碎片：</strong><br>内存分配与管理的方法中需要解决的问题之一就是内存碎片，其产生过程如下图所示，一个新的内存堆被系统按照应用需求分成多个大小不同的内存块。应用在使用完内存后就会进行释放，同时新的应用产生也需要分配新的可用该内存。经过多次申请和释放后，内存块被不断地分割，导致内存中存在大量的很小的内存块。这些内存块太小导致大多数应用无法使用，因此就形成了内存碎片。这些内存碎片的不断增加会导致实际可用内存越来越少。最终应用程序因为分配不到合适的内存而崩溃。而FreeRTOS的heap_4.c就提供了一个解决内存碎片的方法，即将内存碎片进行合并组成一个新的可用的大内存块。<br><img src="https://cdn.jsdelivr.net/gh/AndreLYL/BlogPictures/blog_files/img/20210509005027.png"></p>
<p><strong>heap_1.c简介</strong><br>动态内存分配需要一个内存堆，在FreeRTOS中的内存堆为ucHeap[],大小为configTOTAL_HEAP_SIZE.</p>
<p>heap_1特性如下：</p>
<ol>
<li>使用一旦创建好任务，信号量和队列就再也不会删除的应用，实际上大多数的FreeRTOS的应用都是这样的。</li>
<li>具有可确定性(执行所花费的时间大多数都是一样的)，而且不会导致内存碎片。</li>
<li>代码实现和内存分配的过程都非常简单，内存是从一个静态的数组中分配的，也就是适合与那些不需要动态分配内存的应用。</li>
</ol>
<p><strong>heap_2.c简介</strong></p>
<p><strong>heap_3.c简介</strong></p>
<p><strong>heap_4.c简介</strong><br>heap_4提供了一个最优的内存分配方法，不像heap_2, heap_4会将内存中的碎片合并成一个大的可用内存块，他提供了内存合并算法。内存堆为ucHeap[], 大小同样为configTOTAL_HEAP_SIZE。可以通过函数xPortGetFreeHeapSize()获取剩余内存大小。</p>
<p>heap_4特性如下：</p>
<ol>
<li>可以用在那些需要重复创建和删除任务、队列、信号量和互斥信号量等应用中。</li>
<li>不会像heap_2那样产生严重的内存分配碎片，即使分配的内存大小是随机的。</li>
<li>具有不确定性，但是远比C标准库的malloc()和free()效率高。</li>
</ol>
<p><strong>heap_5简介</strong><br>heap_5使用了heap_4相同的合并算法，内存管理实现基本相同，但是heap_5允许内存堆跨越多个不连续的内存段。如果使用heap_5需要调用函数xPortDefineHeapRegions()来对内存堆做初始化处理，该函数执行完之前禁止调用任何会调用pvPortMalloc()的函数。</p>
<p>参考资料：<br>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336687316">FreeRTOS源码探析之——任务调度相关</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-06T16:00:00.000Z" title="5/7/2021, 12:00:00 AM">2021-05-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-07-19T11:36:54.000Z" title="7/19/2021, 7:36:54 PM">2021-07-19</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">23 minutes read (About 3522 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/07/work/004.RTOS/">FreeRTOS学习笔记01</a></h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p><strong>操作系统</strong>：操作系统是一个用以提供基础计算机功能的计算机程序，它可以向其他程序提供服务，应用来实现用户想要实现的功能。操作系统对应用程序的支持使得开发者在在开发应用程序是更加快捷，简单，易维护。</p>
</li>
<li><p><strong>RTOS</strong>：大部分操作系统允许多个应用程序同时执行，这种成为多任务。但实际上，在任何一个时间点上只有一个进程在独立执行。由于应用程序切换足够快，好像所有的程序同时执行。操作系统中有一个调度器(Scheduler)的部分负责调度应用程序，决定什么时候执行哪个应用程序，调度器在每个程序之间的切换需要足够快速。实时操作系统费的调度器设计成可以提供确定的执行模式。实时性意味着嵌入式系统对某个具体事件的响应必须严格控制在一个预定的deadline内。<strong>实时操作系统会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</strong></p>
</li>
<li><p><strong>线程</strong>：线程是操作系统能够进行运算调度的最小单位，包含在进程中，是进程的实际运作单位。一条线程是进程中的一个单一控制流。线程有四枣红基本状态：产生，阻塞，非阻塞，结束。</p>
</li>
<li><p><strong>进程</strong>：指计算机已运行的程序，是分时系统的基本运作单位。进程是程序的真正运行实例。进程有五种状态：新生，运行，等待，就绪，结束。在单CPU系统中，任何时间可能有多个进程在等待，但必定仅有一个进程在运行。</p>
</li>
<li><p>线程和进程区别：<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，是运行中程序指令的描述。</p>
</li>
</ul>
<p><strong>实时操作系统的设计原则：</strong></p>
<ul>
<li>实时的消息、事件处理机制：常规的操作系统，消息队列是按照FIFO的方式进行调度。实时操作系统会提供基于优先级的处理方式。</li>
<li>提供内核级的优先级翻转处理方式：实时操作系统调度器最精彩遇到的问题是优先级翻转，因此对于类似信号量一类的API，都能提供抑制优先级翻转的机制，防止操作系统死锁。</li>
<li>减少粗粒度的所和长期关中断的使用：这里的所主要是指自旋锁(Spinlock)一类会影响中断的锁，也包括任何关中断的操作，在Windows和Linux的驱动中，为了同步的需要，可能会长期关闭中断，这里的长期可能是毫秒到百微秒级。但实时操作系统通常不允许长期关中断。对于非实时操作系统来说，如果收到外部中断，系统在处理中断的整个过程中可能会一直关中断。但实时操作系统的通常做法是吧中断作为一个事件通告给另外一个任务，interrupt handler在处理完关键数据以后，立即打开中断，驱动的中断处理程序以一个高优先级任务的方式继续执行。</li>
<li>系统级的服务也要保证实时性：对于一些系统级的服务，如文件系统操作，非实时系统过会缓存用户请求，并不直接把数据写入设备，或者建立一系列线程池，分发文件系统的请求。但是实时系统允许高优先级的任务有限写入数据。这种设计会牺牲性能，但是会保证系统的实时性。</li>
<li>避免提供实时性不确定的API：多数实时操作系统都不支持虚拟内存(page file &#x2F; swap area),主要原因是缺页中断(page fault)会导致任务调度的不确定性增加。多数实时操作系统过都支持分页，但很少会使用虚拟内存，因为一次缺页中断的开销十分巨大，通常都是毫秒级。会导致用户程序执行的不确定性增加。</li>
<li>提供针对实时系统调度的专用API：</li>
<li>降低系统抖动：由于关中断的原因，通常情况下，操作系统的调度器不会太精确的产生周期性的调度。一个设计优秀的实时操作系统能把抖动降低到微妙甚至是百纳秒级别。</li>
<li>针对实时性设计的SMP和虚拟化技术：</li>
</ul>
<h3 id="实时性，硬实时，软实时"><a href="#实时性，硬实时，软实时" class="headerlink" title="实时性，硬实时，软实时"></a>实时性，硬实时，软实时</h3><p><strong>实时性：</strong> 实时性也叫实时计算(real-time computing), 实时约束指的是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格时间限制内响应。 换句话说就是，任务(Task)必须在给定的时间(Deadline)内完成。比如汽车安全气囊响应，在汽车检测到撞击后，汽车ECU以及执行器需要在40ms内完全打开气囊，否则就会对乘客安全造成威胁。这个时候就要求汽车ECU的程序运行满足实时性标准。</p>
<p><strong>硬实时：</strong> The firm real-time definition allows for infrequently missed deadlines. In these applications the system can survive task failures so long as they are adequately spaced, however the value of the task’s completion drops to zero or becomes impossible.</p>
<p><strong>软实时：</strong> The soft real-time definition allows for frequently missed deadlines, and as long as tasks are timely executed their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.</p>
<p><strong>区别：</strong> 硬实时操作系统<strong>必须</strong>使任务在确定的时间内完成；软实时操作系统能使<strong>绝大多数的</strong>任务在确定时间内完成。因此，硬实时和软实时的差别是，软实时只能提供统计意义上的实时。只要任务及时执行就会具有价值，如果任务超出Deadline，只会导致价值的稍微降低。如计算机的声音系统就是软实时的任务。 而硬实时任务只要超时，任务的价值就会降低到零。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>调度同来确定多任务环境下任务执行的顺序和获得CPU资源后能执行的时间长度。操作系统通过一个调度程序来实现调度功能。调度程序以函数的形式存在，用来实现操作系统的调度算法。调度程序本身并不是一个任务，是一个函数调用，可在内核的各个部分进行调用。调用调度程序的具体位置成为一个调度点(Scheduling point), 调度点通常处于一下位置：**(i)** 中断服务程序的结束位置；**(ii)** 任务因等待资源而处于等待状态；**(iii)** 任务处于就绪状态时。</p>
<p>在操作系统中，一个任务有三种典型状态：</p>
<ul>
<li>正在运行(Running)：正在CPU中执行</li>
<li>待命(Ready)：等待执行</li>
<li>阻塞(Blocked)：任务暂停，等待一个事件的发生，例如接受一组数据</li>
</ul>
<p>由于CPU在某个事件只能执行一个任务，因此大部分任务在多数事件处于阻塞或待命状态。可能大量的项目在待命列表里等待执行。这取决于系统所需的任务数量和调度器类型。通常情况下，简单的时间触发式调度器，待命任务列表的数据结构要尽可能缩短最坏情况下，程序在调度器关键部分的执行时间，防止其他任务一直在待命列表中无法及时执行。在这种调度器中，应该尽量避免抢占式任务，甚至应该关闭调度器之外的所有中断。并且待命列表的数据结构应该根据系统所需要最大任务数量进行优化。如果列表任务较多，双向链表是一个合适的结构。在任务列表的排序上，应该按照优先级对任务进行排序。这样可以保证高优先级任务的及时执行。</p>
<p><strong>调度算法：</strong><br>实时操作系统需要采用各种算法和策略保证系统行为的可预测性，并且调用一切可利用的资源完成实时控制任务。 其实时调度算法分为三种类别：基于优先级的调度算法(Priority-driven scheduling-PD)，基于CPU使用比例的共享式调度算法(Share-drivescheduling-SD)，基于时间进程的调度算法(Time—driven schedulinq-TD)。</p>
<p>基于优先级的调度算法给每个进程分配一个优先级，在每次进程调度的时候，最高优先级任务首先被执行。算法的类型分为两种：</p>
<p>静态调度：静态调度在系统开始运行前进行调度，严格的静态调度在系统运行时无法对任务重新调度。静态调度的目标是把任务分配给各个处理机，并对每一处立即给出所要运行的静态运行顺序。静态调度算法实现简单</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>死锁：</strong> 死锁是指一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用的不会释放的资源而处于的一种永久等待的状态。</p>
<p><strong>死锁的四个条件：</strong> </p>
<ul>
<li>互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用</li>
<li>请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源</li>
<li>非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制的剥夺</li>
<li>循环等待条件(Circular wait)：系统中的若干进程组成的环路，该环路中每个进程都在灯带相邻进程正占用的资源</li>
</ul>
<p><strong>互斥锁：</strong> 互斥锁是一种独占锁，当线程A加锁成功后，此时的互斥锁已经被线程A独占了，只要A没有释放受众的锁，线程B加锁就会失败，于是就是会释放CPU让给其他线程，既然B释放了CPU，也就意味着线程B的加锁代码会被阻塞。对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。</p>
<p><strong>自旋锁：</strong> 自旋锁是一种特殊的互斥锁，当资源被加锁后，其他线程想要再次加锁，此时该线程不会被阻塞睡眠而是陷入循环等待状态(CPU不能做其他事情)，循环检查资源持有者是否已经释放了资源，这样做的好处是减少了线程从睡眠到唤醒的资源消耗，但是会一直占用CPU资源。适用于资源的锁被持有时间段，而又不希望在线程的唤醒上花费太多资源的情况。</p>
<ol>
<li>自旋锁为什么不能睡眠？<br> 因为需要循环检测lock变量。</li>
</ol>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ol>
<li><strong>介绍一下FreeRTOS的内存管理？</strong></li>
</ol>
<ul>
<li>heap_1：只申请不释放，适用于一旦创建好任务，信号量和队列就再也不会删除的应用。</li>
<li>heap_2：最佳匹配，即申请又释放，适用于可能会重复的删除的任务，队列，信号量等应用中，需要注意内存碎片的产生问题。</li>
<li>heap_3：简单封装malloc,free,对其进行线程保护。使用时需要编译器提供一个内存堆，编辑器库需要提供malloc()和free()函数。</li>
<li>heap_4：最佳匹配+合并相邻内存，具有不确定性，但不会产生严重的内存碎片</li>
<li>heap_5：最佳匹配+合并不连续的内存区。</li>
</ul>
<ol start="2">
<li><strong>简述RTOS中，栈空间的最大使用率和栈溢出的检测方法？</strong></li>
</ol>
<ul>
<li>方法一：在任务切换时检测任务指针是否越界，如果越界就会在任务切换时触发栈溢出的钩子函数</li>
<li>方法二：在任务创建的时候将任务战所有数据初始化为0Xa5，任务切换进行任务栈检测时检测末尾的16个字节是否都是0xa5，通过这种方式检测栈是否溢出。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012993936/article/details/41145863">https://blog.csdn.net/u012993936/article/details/41145863</a><br>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86861756">https://zhuanlan.zhihu.com/p/86861756</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-05-02T16:00:00.000Z" title="5/3/2021, 12:00:00 AM">2021-05-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-05-09T08:40:04.000Z" title="5/9/2021, 4:40:04 PM">2021-05-09</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 minutes read (About 2386 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/03/work/Emmbed_system_QA/">嵌入式面试常见问题整理</a></h1><div class="content"><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="单工，半双工，全双工"><a href="#单工，半双工，全双工" class="headerlink" title="单工，半双工，全双工"></a>单工，半双工，全双工</h4><ul>
<li>单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。</li>
<li>半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。</li>
<li>-全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。</li>
</ul>
<h4 id="FLASH-和-EEPROM区别"><a href="#FLASH-和-EEPROM区别" class="headerlink" title="FLASH 和 EEPROM区别"></a>FLASH 和 EEPROM区别</h4><p>基本概念：</p>
<ul>
<li>ROM： Read-Only Memory</li>
<li>RAM： Random Access Memory</li>
<li>FLASH: Flash 存储器（FLASH EEPROM）又称闪存，快闪。它是EEPROM的一种。它结合了ROM和RAM的长处。不仅具备电子可擦除可编辑（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据</li>
<li>EEPROM: Electrically-Erasable Programmable Read-Only Memory</li>
<li>SRAM：静态RAM，读写速度非常快，比较昂贵。一般用于CPU的一级缓冲，二级缓冲。</li>
<li>DRAM：动态RAM，DRAM保留数据的时间很短，速度比SRAM慢，但是比任何ROM快。计算机的内存是DRAM。</li>
</ul>
<p>FLASH和EEPROM的最大区别是FLASH按扇区操作，EEPROM则按字节操作，二者寻址方法不同，存储单元的结构也不同，FLASH的电路结构较简单，同样容量占芯片面积较小，成本自然比EEPROM低，因而适合用作程序存储器，EEPROM则更多的用作非易失的数据存储器。</p>
<p>目前的单片机，RAM主要是做运行时数据存储器,FLASH主要是程序存储器,EEPROM主要是用以在程序运行保存一些需要掉电不丢失的数据. </p>
<ol>
<li><strong>Nano Flash和NOR Flash的区别：</strong><br>目前Flash主要有NANO和NOR两种</li>
</ol>
<ul>
<li>NOR Flash：该种Flash的读写和创建的SDRAM读写一样，用户可以直接运行装载在NOR Flash里面的代码，这样可以减少SRAM的容量从而节约成本。</li>
<li>NANO Flash：NAND Flash没有采取内存的随即读取技术，它的读取是一次读取一块的形式来进行的，通常是一次读取512个字节，采用这种技术的Flash比较廉价，用户无法直接运行上面的代码。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-0f09c39ef43d96bbb68864e85ed9fcd0_720w.jpg"></p>
<h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><h4 id="CAN总线协议-Controller-Area-Network"><a href="#CAN总线协议-Controller-Area-Network" class="headerlink" title="CAN总线协议(Controller Area Network)"></a>CAN总线协议(Controller Area Network)</h4><p>CAN总线协议是由博世开发的一种基于消息广播模式的串行通信总线，该协议非常适合于现场控制领域，主要用于实现汽车ECU之间的可靠通信。该通讯协议最高速率可达到1Mbps, 容错能力强。CAN控制器包含强大的检错和处理机制。另外CAN的节点之间不会传输大数据块，一帧CAN消息最多传输8字节用户数据。</p>
<p><strong>总线特点</strong></p>
<ul>
<li><strong>多主控制</strong>，总线空闲时所有单元都可以发送消息，最先访问总线的单元获得发送权，多个单元同时发送时，发送优先级高的可以发送。发送的消息保温不包含原地址和目标地址，只通过标识符表示消息的功能和优先级。</li>
<li><strong>总线为事件触发型</strong>，只有消息要发送时，节点才向总线上广播消息; 同时每个节点也可以通过发送远程帧请求其他节点发送数据。</li>
<li><strong>总线上可同时连接多个节点</strong>，可连接节点总数在理论上是没有限制的，实际可连接的节点数受总线上的时间延迟和电气负载限制。</li>
<li><strong>符合OSI通信系统参考模型</strong>，属于物理层和数据链路层。两线式总线结构，电气信号为差分式，通信介质可以采用双绞线，同轴电缆和光导纤维，一般采用双绞线。</li>
<li><strong>总线电平</strong>：显性(Dominant): 0, 隐性(Recessive): 1, CAN总线的信号电平具有线与特性，即显性电平0总是会掩盖隐性电平1，如果不同的节点同时发送显性和隐性电平，总线总是表现出显性电平。只有所有节点发送隐性电平是，总线才表现为隐性。<strong>线与特性是CAN总线仲裁机制的电路基础</strong>。</li>
<li><strong>高速CAN</strong>：总线通信速度最高1Mbp(40m条件下)。高速CAN时，CANH与CANL电压相同时为逻辑“1” (CANH&#x3D;CANL&#x3D;2.5V)。CANH和CANL电压相差2V时为逻辑“0” (CANH&#x3D;3.5V, CANL&#x3D;1.5V)。高速CAN收发器在共模电压范围内(-12V~12V),将CANH和CANL电压差大于0.9V成为显性状态，将CANH和CANL电压差小于0.5定义为隐性状态。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/917884/201906/917884-20190629175927325-911993050.png" alt="高速CAN信号电平（ ISO 11898-2）"></p>
<ul>
<li><strong>低速CAN</strong>：定义CANH和CANL电压相差 5V （CANH &#x3D; 0V, CANL &#x3D; 5V）时为逻辑“1”，相差 2.2V （CANH &#x3D; 3.6V, CANL &#x3D; 1.4V）时为逻辑“0”。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/917884/201906/917884-20190629180018330-1726697444.png" alt="低速CAN信号电平（ ISO 11898-3）"></p>
<p><strong>CAN报文帧结构</strong>：在CAN总线上，报文以“帧”的形式发送，每个报文帧包含以下部分：</p>
<ul>
<li>帧起始：总线空闲时为隐性状态，帧起始由单个显性位构成，标志报文开始，在总线上起同步作用。</li>
<li>仲裁段：仲裁段由报文的标识符完成，即ID，标准CAN的标识符为11位，扩展CAN中为29位。</li>
<li>控制段：主要定义了数据域的字节长度，通过数据长度码，接收节点可以判断报文数据是否完整。</li>
<li>数据域：主要包含0~8个字节数据。</li>
<li>CRC域：循环冗余码校验</li>
<li>帧结束：由一串七个隐性位组成，表示报文帧的结束。</li>
</ul>
<p><strong>CAN报文帧种类</strong></p>
<p>（1）数据帧：由发送节点发出，包含0 - 8个数据字节。</p>
<p>（2）远程帧：发送远程帧向网络节点请求发送某一标识符的数据帧。</p>
<p>（3）错误帧：总线节点发现错误时，以错误帧的方式通知网络上的其他节点。</p>
<p>（4）过载帧：发送过载帧，表示当前节点不能处理后续的报文（如帧延迟等）。</p>
<h4 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h4><p>SPI(Serial Peripheral interface)串行外围设备接口，该接口主要用在EEPROM，Flash，实时时钟，AD转化器，数字信号处理器和数字信号解码器之间。</p>
<ul>
<li>该协议是一种高速的，<strong>全双工同步串行</strong>通信总线。</li>
<li>没有速度限制，一般可达到10Mbps。</li>
<li>主要有四根线：MOSI， MISO，SCLK，CS(片选，选择从设备)。数据在上升下降沿改变。</li>
<li>优点：全双工通信，简单，传输速率快</li>
<li>缺点：没有指定的流控制，没有应答机制确认是否收到数据，相对IIC可靠性不高。</li>
</ul>
<ol>
<li>SPI的四种模式：<br>SPI有四种工作模式，SPI为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟的极性(CPOL)和时钟相位(CPHA)可以进行配置。CPOL决定SPI空闲时，时钟信号的电平。CPHA决定SPI在SCLK的第几个边沿开始采样数据。</li>
</ol>
<ul>
<li>CPOL&#x3D;0：串行同步时钟的空闲状态是低电平</li>
<li>CPOL&#x3D;1：串行同步时钟的空闲状态是高电平</li>
<li>CPHA&#x3D;0：SPI在串行同步时钟的第一个跳边沿开始采样</li>
<li>CPHA&#x3D;1：SPI在串行同步时钟的第二个跳边沿开始采样</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>DMA(Direct Memory Access),即直接存储器访问，DMA的传输方式可以无需CPU直接进行控制传输，也没有中断处理方式那样的保护现场和恢复现场的过程。通过硬件为RAM与I&#x2F;O设备开辟一条直接传输数据的通路，可以使CPU的效率大为提高。</p>
<ul>
<li>作用： 用于内存和内存之间或内存和外设之间的高速数据传输。</li>
</ul>
<ol>
<li><strong>DMA传输包括哪些操作？</strong>(STM32为例)<br>每一次DMA传输包括三个操作<ul>
<li>通过DMA的寄存器寻址，从外设数据寄存器或存储器单元加载数据。</li>
<li>DMA计数器在数据存储结束后递减，该计算器中包含仍需执行的事务数目。</li>
</ul>
</li>
</ol>
<p>产生事件后，外设会向DMA控制器发送请求信号，DMA控制器根据通道优先级处理该请求，只要DMA控制器访问外设，DMA控制器就会向外设发送确认信号，外设获得确认信号后，便会立即释放请求。一旦外设使请求失效，DMA就会释放确认信号。如果有更多的请求，外设可以启动下一个事务。</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h3 id="Static关键字作用"><a href="#Static关键字作用" class="headerlink" title="Static关键字作用"></a>Static关键字作用</h3><h3 id="Const关键字作用"><a href="#Const关键字作用" class="headerlink" title="Const关键字作用"></a>Const关键字作用</h3><h3 id="Voilatile关键字作用"><a href="#Voilatile关键字作用" class="headerlink" title="Voilatile关键字作用"></a>Voilatile关键字作用</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-04-30T16:00:00.000Z" title="5/1/2021, 12:00:00 AM">2021-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-05-11T05:39:22.000Z" title="5/11/2021, 1:39:22 PM">2021-05-11</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">16 minutes read (About 2376 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/01/work/001.c_basic/">C语言基础-嵌入式面试</a></h1><div class="content"><h3 id="1-C和C-区别："><a href="#1-C和C-区别：" class="headerlink" title="1. C和C++区别："></a>1. C和C++区别：</h3><ul>
<li>C语言：面向过程的语言，其核心关注于问题是如何被解决的，把实现一个软件功能的过程分为一个个过程。 例如汽车要去加油，其过程为：汽车启动-&gt;汽车行驶-&gt;汽车加油。在这里我们不关注物件本身(汽车这个对象)，默认定义执行该过程的主题是汽车。</li>
<li>C++语言： 面向对象的语言，在计算机科学中的对象既可以表示客观世界的问题空间(namespace)中的具体的某个事物，又可以表示软件系统解空间的基本元素，如变量、数据结构、函数等。例如汽车要去加油，汽车&lt;启动，开车，加油&gt;, 我们关注物件(对象)本身，只需要考虑什么时间干什么事。启动，开车，加油属于这个物件的基本属性。</li>
</ul>
<h2 id="C语言基础部分："><a href="#C语言基础部分：" class="headerlink" title="C语言基础部分："></a>C语言基础部分：</h2><ul>
<li><strong>标识符：</strong> 一个标识符以字母或者下划线开始的后面可以跟多个字母、数字、下划线。C标识符中不允许出现标点字符，并且区分大小写。</li>
<li><strong>关键字：</strong> C中的保留字，这些保留字不能作为常量名，变量名和其他标识符的名称。常用的的关键字包括:while, do, for, break, continue, default, goto, char, double, int, long, short, float,</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auto</td>
<td align="left">声明自动变量</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">定义常量，如果一个变量可以被const修饰，那么它的值就不能被在改变</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left">声明枚举类型</td>
</tr>
<tr>
<td align="left">extern</td>
<td align="left"><strong>声明变量</strong>或函数是在其他文件或本文件其他位置定义</td>
</tr>
<tr>
<td align="left">register</td>
<td align="left">声明寄存器变量</td>
</tr>
<tr>
<td align="left">sizeof</td>
<td align="left">计算数据类型或变量长度(即所占的字节数)</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">声明静态变量</td>
</tr>
<tr>
<td align="left">typeof</td>
<td align="left">给数据类型取别名</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">声明共用体类型</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">声明函数无返回值或者无参数，<strong>声明无类型指针</strong></td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">说明变量在程序执行中可以被隐含的改变</td>
</tr>
</tbody></table>
<ul>
<li>**数据类型： ** C语言有四种数据类型：<ul>
<li>**基本数据类型: **他们是算术类型，包括整数类型和浮点类型，注意char是属于整数类型的。 基本数据类型占用的空间(64位机器)：char-1字节，int-4字节， float-4字节，double-8字节。</li>
<li><strong>枚举类型：</strong> 他们也是算术类型，被用来定义在程序中，只能赋予其一定的离散整数值的变量</li>
<li><strong>void类型：</strong> 类型说明符 void表明没有可用的值</li>
<li><strong>派生类型：</strong> 它们主要包括：指针，数组，结构，共用体，和函数类型</li>
<li><strong>强制类型转换：</strong> (类型说明符)(表达式)</li>
</ul>
</li>
</ul>
<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a><strong>变量：</strong></h4><p>变量是程序可操作的存储区名称。<strong>全局变量</strong>保存在内存的全局存储区中，占用静态的存储单元；<strong>局部变量</strong>保存在栈中，只有在所在函数被调用的时候才动态地为变量分配存储单元。</p>
<p><strong>C语言经过编译后将内存分为一下几个区域：</strong></p>
<ul>
<li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程的各种参数，局部变量，返回值以及函数的返回地址。操作方式类似于数据中的栈。</li>
<li>堆(heap): 用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则在程序结束后由系统自动回收。注意：这里的对并不是数据结构中的堆。</li>
<li>全局(静态)存储区: 分为DATA和BSS段，DATA段(全局初始化区)存放初始化的全局变量和静态变量；BSS段(全局未初始化分区) 存放未初始化的全局变量和静态变量。程序运行结束时自动释放，其中在BSS段在程序执行之前会被系统自动清零，所以未初始化的全局变量和静态变量在程序执行之前已经为0.</li>
<li>文字常量区：存放常量字符串，程序结束由系统释放。</li>
<li>程序代码区：存放程序的二进制代码。</li>
</ul>
<p>因此，C语言的全局变量和局部变量在内存之中是有区别的，C语言的全局变量包括外部变量和静态变量，均是保存在全局存储区中，占用永久性的存储单元；局部变量，即自动变量，保存在栈中，只有在所在的函数被调用时才有系统动态在栈中分配临时性的存储单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int k1 = 1;</span><br><span class="line">int k2;</span><br><span class="line">static int k3 = 2;</span><br><span class="line">static int k4;</span><br><span class="line">int main( )</span><br><span class="line">&#123;  staticint m1=2, m2;</span><br><span class="line">    inti=1;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[10] = &quot;hello&quot;;</span><br><span class="line">    char*q = &quot;hello&quot;;</span><br><span class="line">    p= (char *)malloc( 100 );</span><br><span class="line">    free(p);</span><br><span class="line">    printf(&quot;栈区-变量地址  i：%p\n&quot;, &amp;i);</span><br><span class="line">    printf(&quot;                p：%p\n&quot;, &amp;p);</span><br><span class="line">    printf(&quot;              str：%p\n&quot;, str);</span><br><span class="line">    printf(&quot;                q：%p\n&quot;, &amp;q);</span><br><span class="line">    printf(&quot;堆区地址-动态申请：%p\n&quot;, p);</span><br><span class="line">    printf(&quot;全局外部有初值 k1：%p\n&quot;, &amp;k1);</span><br><span class="line">    printf(&quot;    外部无初值 k2：%p\n&quot;, &amp;k2);</span><br><span class="line">    printf(&quot;静态外部有初值 k3：%p\n&quot;, &amp;k3);</span><br><span class="line">    printf(&quot;    外静无初值 k4：%p\n&quot;, &amp;k4);</span><br><span class="line">    printf(&quot;  内静态有初值 m1：%p\n&quot;, &amp;m1);</span><br><span class="line">    printf(&quot;  内静态无初值 m2：%p\n&quot;, &amp;m2);</span><br><span class="line">    printf(&quot;文字常量地址    ：%p, %s\n&quot;,q, q);</span><br><span class="line">    printf(&quot;程序区地址      ：%p\n&quot;,&amp;main);</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量是固定值，在程序的执行期间不会改变。它可以是任意基本的数据类型，整数常量，浮点常量，字符常量，枚举常量等。</p>
<ul>
<li><strong>定义常量：</strong> 定义常量有两种方法，使用#define或者使用const关键字，这两种方法从本质上是不同的。#define 是宏定义，它不能定义常量，但宏定义可以实现在字面意义上和其它定义常量相同的功能，本质的区别就在于 #define 不为宏名分配内存，而 const 也不为常量分配内存，怎么回事呢，其实 const 并不是去定义一个常量，而是去改变一个变量的存储类，把该变量所占的内存变为只读！<br> <img src="https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15.png"><br>示例<br>  #define length 10<br>  #define NEWLINE ‘\n’<br><br>  const int var&#x3D;5;</li>
<li>整数常量：整数常量可以是十进制，八进制，十六进制的常量，前缀指定基数，0x&#x2F;0X表示十六进制，0表示八进制，不带前缀默认代表十进制。<strong>整数常量也可以带一个后缀，U代表无符号整数, L代表长整数，大小写和顺序任意。</strong></li>
</ul>
<h3 id="C-语言的三大特性"><a href="#C-语言的三大特性" class="headerlink" title="C++语言的三大特性"></a>C++语言的三大特性</h3><ul>
<li><strong>封装：</strong> C++语言支持数据封装，类是数据封装的工具，对象是数据封装的实现，在封装中，还提供一种对数据访问控制的机制，是的一些数据隐藏在封装体内，具有隐藏性。封装和外接的信息交换是通过操作接口进行的，这种访问的控制机制体现在类的共有成员(public)，私有成员(private)，和保护成员(protected)上。私有成员只有类内说明的一些函数才能访问；共有成员类外的函数也可以访问，保护成员只有该类的成员函数和派生类才能访问。</li>
<li><strong>继承：</strong> C++语言允许单继承和多继承。一个类可以根据需要生成它的派生类，派生类还可以再生成派生类。派生类可以继承基类的成员同时也可以定义自己的成员。继承是实现数据抽象和共享的一种机制。该机制可以避免不能重复利用程序导致的资源浪费。</li>
<li><strong>多态：</strong> 多态指的是对不同类发出的相同消息会有不同的实现。多态性也可以理解为，在一般类中定义的属性和服务被特殊类继承后，可以具有不同的数据类型或不同的实现。简单来说，多态性指的是发出同样的消息被不同的数据类型的对象接收后会导致不同的行为。C++支持多态性主要表现在：C++语言允许函数重载和运算符重载；C++语言通过定义虚函数来支持动态联编。多态特性的工作依赖虚函数的定义，在需要解决多态问题的重载成员函数前，加上virtual关键字，那么该成员函数就变成了虚函数，从上例代码运行的结果看，系统成功的分辨出了对象的真实类型，成功的调用了各自的重载成员函数。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-02-05T16:00:00.000Z" title="2/6/2021, 12:00:00 AM">2021-02-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-02-06T19:28:24.000Z" title="2/7/2021, 3:28:24 AM">2021-02-07</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">a few seconds read (About 82 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/06/Algorithm/003.vector_cplusplus/">C++：vector容器</a></h1><div class="content"><h3 id="二维向量的遍历方法"><a href="#二维向量的遍历方法" class="headerlink" title="二维向量的遍历方法"></a>二维向量的遍历方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//二维向量的遍历，迭代器遍历</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; array = &#123;&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;&#125;;  </span><br><span class="line">vector&lt;vector&lt;int &gt;&gt;::iterator iter;</span><br><span class="line">for (iter = array.begin(); iter != array.end() ; ++iter) &#123;</span><br><span class="line">    for (int i = 0; i &lt; (*iter).size(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; (*iter)[i] &lt;&lt; &quot; &quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//二维向量的遍历，数组下表</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; array = &#123;&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;&#125;;  </span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; array.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j = 0; j &lt; array[i].size(); j++)</span><br><span class="line">        cout &lt;&lt; V[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-24T16:00:00.000Z" title="1/25/2021, 12:00:00 AM">2021-01-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-01-25T18:18:04.000Z" title="1/26/2021, 2:18:04 AM">2021-01-26</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">2 minutes read (About 225 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/25/Algorithm/001.is_prime/">算法：判断质数</a></h1><div class="content"><p>质数定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。</p>
<h3 id="思路1：定义"><a href="#思路1：定义" class="headerlink" title="思路1：定义"></a>思路1：定义</h3><p>根据定义，采用2到n-1中的每一个数去除n，如果不能被整除，则该数为质数。时间复杂度：O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    bool isprime = true;</span><br><span class="line">    for(int i=2; i &lt; n; i++)&#123;</span><br><span class="line">        if(n % i==0)&#123;</span><br><span class="line">            isprime=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isprime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="思路2：质数筛选定理"><a href="#思路2：质数筛选定理" class="headerlink" title="思路2：质数筛选定理"></a>思路2：质数筛选定理</h3><p><strong>质数筛选定理：</strong> 如果n不能够被不大于根号n的任何质数整除，则n是一个质数。<br><strong>参考链接：</strong> </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100051075">https://zhuanlan.zhihu.com/p/100051075</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wo17fang/article/details/47656769">https://blog.csdn.net/wo17fang/article/details/47656769</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool is_prime(int n)&#123;</span><br><span class="line">    bool isprime= true;</span><br><span class="line">    int max = static_cast&lt;int&gt;(sqrt(n)); \\隐式类型转换</span><br><span class="line">    for(int j=2; j&lt;=max; j++)&#123;</span><br><span class="line">        if(n%j == 0)&#123;</span><br><span class="line">            isprime=false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    return isprime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-01-24T16:00:00.000Z" title="1/25/2021, 12:00:00 AM">2021-01-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-01-27T04:56:42.000Z" title="1/27/2021, 12:56:42 PM">2021-01-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">12 minutes read (About 1868 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/25/Algorithm/002.algorithm_sorting/">排序算法</a></h1><div class="content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>排序算法是程序设计中最基本的算法，常用的排序算法有十种，可以分为内部排序和外部排序两种类型：</p>
<h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3><ul>
<li>内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。</li>
<li>常见的内部排序算法：冒泡排序，快速排序，插入排序，选择排序，希尔排序，堆排序。</li>
</ul>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><ul>
<li>外部排序是针对于极大量数据的排序算法，由于数据无法一次放入内存，算法采用“排序-归并” 策略，首先将部分数据依次读入内存，排序后生成有序的临时文件，在归并阶段将这些临时文件组成较大的有序文件。</li>
<li>常见的外部排序算法有归并排序，计数排序，桶排序，基数排序。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png"><br>关于排序算法的简单介绍：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png"></p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>如果两个具有相同键的对象在输入输出中的顺序与在输入未排序数组中出现的顺序相同，则该排序算法被认为是稳定的。有些排序算法本质上是稳定的，例如插入排序，合并排序，冒泡排序等。而有些排序算法则不是，例如堆排序，快速排序等。</p>
<p>但是，任何给定的不稳定算法都可以修改为稳定。可以使用特定的排序算法来使其稳定，但是通常，可以通过更改键比较操作将本质上不稳定的任何基于比较的排序算法修改为稳定，以便将两个键的比较视为位置。具有相同键的对象的系数。<a target="_blank" rel="noopener" href="http://www.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf">参考文献</a><br><img src="https://i1.wp.com/i.stack.imgur.com/alljt.png"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br><strong>算法步骤：</strong></p>
<ol>
<li>以升序为例，比较相邻两个元素大小，如果第一个元素大于第二个，则交换两个元素，否则不做改变。</li>
<li>从数组的第一个元素开始，遍历到数组的倒数第二个元素。</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void bubble_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int i = 0; i &lt; len-1; i++)&#123;</span><br><span class="line">        for(int j = 0; j&lt;len-1-i; j++)&#123;</span><br><span class="line">            if(num[j] &gt; num[j+1]) </span><br><span class="line">                swap(num[j], num[j+1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; num= &#123; 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 &#125;;</span><br><span class="line">    int len = num.size();</span><br><span class="line">    for(int i=0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    Bubble_sort(num, len);</span><br><span class="line">    for(int i=0; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的方法为第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。<br><strong>算法步骤：</strong></p>
<ol>
<li>记录数据中的第一个元素的index</li>
<li>遍历数据并与该元素进行比较，如果小于该元素则更新index，完成遍历后交换第一个元素和index所指向的最小值。</li>
<li>重复以上步骤直至完成排序。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void selection_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    int min;</span><br><span class="line">    for(int i=0; i&lt;len; i++)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for(int j=i; j&lt;len; j++)&#123;</span><br><span class="line">            if(num[j] &lt; num[min])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void intersection_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int i=1; i&lt;len; i++)&#123;</span><br><span class="line">        for(int j=i; j&gt;0; j--)&#123;</span><br><span class="line">            if(num[j] &lt; num[j-1])</span><br><span class="line">                swap(num[j-1], num[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br>希尔排序原理的视频介绍：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rE411g7rW?from=search&seid=7021456873332538636">希尔排序</a></li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif"></p>
<p><strong>算法实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(vector&lt;int&gt; &amp;num, int len)&#123;</span><br><span class="line">    for(int gap = len / 2; gap &gt; 0; gap /= 2)</span><br><span class="line">        for(int i = gap; i &lt; len; i++)&#123;</span><br><span class="line">            int temp = num[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for( ; j &gt;= gap &amp;&amp; temp &lt; num[j-gap]; j-=gap)</span><br><span class="line">                num[j] = num[j-gap];</span><br><span class="line">            num[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是在实践中最快的已知排序算法，算法的平均运行时间是O(NlogN), 最坏的性能为O(N^2).<br><strong>算法步骤：</strong></p>
<ol>
<li><p>从数列中随机挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
</li>
</ol>
<p><strong>算法实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p>
</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif"></p>
<p>参考资料：<br>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/renyp8799/article/details/9329681?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">关于排序算法的一点知识——实例和伪代码</a><br>[2] </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-04-30T16:00:00.000Z" title="5/1/2020, 12:00:00 AM">2020-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-07-30T18:40:00.000Z" title="7/31/2020, 2:40:00 AM">2020-07-31</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">a minute read (About 201 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/01/Major/08.learn_pytorch/">pytorch学习</a></h1><div class="content"><h3 id="pytorch常用代码"><a href="#pytorch常用代码" class="headerlink" title="pytorch常用代码"></a>pytorch常用代码</h3><ul>
<li>在pytorch中使用tensorboard: <a target="_blank" rel="noopener" href="https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/">https://www.pytorchtutorial.com/pytorch-builtin-tensorboard/</a></li>
<li>pytorch常用代码段合集： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59205847">https://zhuanlan.zhihu.com/p/59205847</a></li>
</ul>
<h3 id="pytorch踩坑记录"><a href="#pytorch踩坑记录" class="headerlink" title="pytorch踩坑记录"></a>pytorch踩坑记录</h3><ol>
<li>ERROR: Unexpected bus error encountered in worker. This might be caused by insufficient shared memory (shm)<ul>
<li>出现这个错误的情况是，在服务器上的docker中运行训练代码时，batch size设置得过大，shared memory不够（因为docker限制了shm）.解决方法是，将Dataloader的num_workers设置为0.</li>
<li>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59271905">https://zhuanlan.zhihu.com/p/59271905</a></li>
</ul>
</li>
<li>AttributeError: module ‘scipy.misc’ has no attribute ‘toimage’<ul>
<li><pre><code>解决方法：由于安装的scipy版本是1.4版本，该版本删除了toimage函数，最方便的解决办法降版本
</code></pre>
  $ pip uninstall scipy<br>  $ pip install scipy&#x3D;&#x3D;1.2.0</li>
</ul>
</li>
<li>ModuleNotFoundError: No module named ‘tkinter’<ul>
<li>在utils.py中添加以下代码：<br>  import matplotlib<br>  matplotlib.use(‘agg’)<br>  import matplotlib.pyplot as plt</li>
</ul>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-04-07T16:00:00.000Z" title="4/8/2020, 12:00:00 AM">2020-04-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-07-30T18:43:48.000Z" title="7/31/2020, 2:43:48 AM">2020-07-31</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">26 minutes read (About 3861 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/08/Major/04.Pixor/">基于鸟瞰图的点云目标检测：PIXOR</a></h1><div class="content"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>该文章解决了在自动驾驶环境下从点云实时检测三维物体的问题。因为检测是安全的必要组成部分，所以计算速度至关重要。然而，由于点云的高维性，现有方法的计算成本很高。本文通过从鸟瞰图( BEV )中表示场景来更有效地利用3D数据，并提出PIXOR，这是一种无需处理的、单级的检测器，输出从像素级别的神经网络定向解码估计3D对象。模型的输入形式、网络架构和优化器是为了平衡高精度和实时效率而特别设计的。作者在两个数据集上验证PIXOR的效果——KITTI BEV对象检测基准数据集和大规模3D车辆检测基准数据集。在这两个数据集上，我们表明检测器在平均精度(AP)方面明显优于其他最先进的方法，同时仍以大于28 FPS的速度运行。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在过去的几年里，我们已经看到了大量利用卷积神经网络来产生精确的2D物体检测的方法，通常是从单个图像为主的模型（如Faster R-CNN和YOLO）。然而，在机器应用中，例如自主驾驶，我们对检测3D空间中的物体更为感兴趣。为了规划安全路线，这是运动规划的基础。</p>
<p>3D对象检测的最新方法利用不同的数据源。基于相机的方法利用单目或立体图像（双目摄像机RGB+HHA）。然而，从2D图像中精确的3D估计是困难的，特别是在长距离范围内。随着廉价RGB-D传感器如微软Kinect、英特尔RealSense和苹果PrimeSense的普及，出现了几种利用深度信息并将其与RGB图像融合的方法。与单目方法相比，它们已经显示出显著的性能提升。在自动驾驶的情况下，像LIDAR(光探测和测距)这样的高端传感器更常见，因为为了安全需要更高的精确度。处理LIDAR数据的主要困难是传感器以点云的形式产生非结构化数据，每360度扫描通常包含大约10^5个3D点。这给现代探测器带来了巨大的计算挑战。</p>
<p>在三维物体检测的背景下，已经探索了不同形式的点云表示。主要的想法是形成一个结构化的表示，其中可以应用标准卷积运算。现有表示主要分为两种类型: 3D体素网格和2D投影。3D体素网格将点云转换成规则间隔的3D网格，其中每个体素单元可以包含标量值(例如，占用率)或矢量数据(例如，根据该体素单元内的点计算的统计数据)。3D卷积通常用于从体素网格中提取高阶表示。然而，由于点云本质上是稀疏的，因此体素网格非常稀疏，很大一部分计算是冗余和不必要的，用这种表示的典型系统仅运行在1-2 FPS。</p>
<p>另一种方法是将点云投影到平面上，然后将平面离散为基于2D图像的表示，在此应用2D卷积。在离散化期间，手工制作的特征(或统计)被当做2D图像的像素值计算。常用的投影是范围视图(即360度全景视图)和鸟瞰图(即俯视图)。这些基于2D投影的表示更加紧凑，但是它们在投影和离散化过程中会带来信息损失。例如，范围视图投影将具有失真的对象大小和形状。为了减轻信息损失，MV3D建议将2D投影与摄像机图像融合，以带来额外信息。然而，融合模型相对于输入模态的数量具有近似线性的计算成本，使得实时应用不可行。</p>
<p>在这篇论文中，作者提出了一种精确的实时三维物体检测器，称之为PIXOR (ORiented 3D object detection from PIXel-wise neural network predictions)，它是在点云上运行的网络。PIXOR是一种单级、无二次处理（例如YOLO和SSD）的密集物体检测器，它以高效的方式利用2D鸟瞰图(BEV)表示。我们选择BEV表示，因为它在计算上比3D体素网格更友好，并且还保留了度量空间，这使得我们的模型能够探索关于对象类别大小和形状的先验。我们的探测器在鸟瞰图中输出真实世界尺寸的精确定向边界框。请注意，这些是三维估计，但必须假设物体在地面上，因为车辆不会飞，这也是自动驾驶场景中的合理假设。</p>
<p>作者在两个数据集上展示了其方法的有效性。具体来说，PIXOR在所有先前的方法中，实现了KITTI鸟瞰对象检测基准的最高平均精度(AP)，同时也是其中运行最快的(超过28FPS)。作者还在KITTI上提供了深入的消融研究，以调查每个模块贡献了多少性能增益，并通过将其应用于大规模TOR4D数据集来证明PIXOR的可扩展性和泛化能力。</p>
<h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>在本文中，作者提出了一种高效的三维物体检测器，它能够在给定LIDAR点云的情况下产生非常精确的边界框。这里的边界框估计不仅包含3D空间中的位置，还包含航向角，因为准确预测这对于自主驾驶非常重要。我们利用LIDAR点云的2D表示，因为它比3D体素网格表示更紧凑，因此可以进行实时推断。图1显示了提议的3D物体检测器的概述。</p>
<p><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh8muz5up6j30zb0cn0vm.jpg" alt="模型检测管道"></p>
<h3 id="Input-Representation"><a href="#Input-Representation" class="headerlink" title="Input Representation"></a>Input Representation</h3><p>由于要用标准卷积神经网络执行卷积操作，因此我们必须假设输入位于网格上。然而，3D点云是非结构化的，因此标准卷积不能直接应用在其上。一种选择是使用体素化来形成3D体素网格，其中每个体素单元包含位于该体素内的点的某些统计数据。为了从三维体素网格中提取特征表示，经常使用三维卷积。但这3DCNN的计算代价非常昂贵，并且因为LIDAR点云非常稀疏，以至于大多数体素单元都是空的。</p>
<p>相反，我们可以单独从鸟瞰图(BEV)中描绘场景。通过将维度从三维降低到二维，而不会丢失点云中的信息。因为我们可以将高度信息保留到颜色通道中。不仅如此，我们还有效地得到了更紧凑的表示方式，因为可以对BEV表示应用2D卷积。在自动驾驶的情况下，因为感兴趣的对象是在同一场地上，这种尺寸减小是合理的。除了计算效率之外，BEV表示还有其他优势。与前视图表示相比，由于对象不相互重叠，因此它简化了对象检测的问题。它还保留了度量空间，因此网络可以利用物体物理尺寸的先验信息。</p>
<p>体素化LIDAR表示的常用特征是占有率occupancy、强度intensity(也称反射率)、密度和高度特征。在PIXOR中，作者只使用占用率和强度作为特征。作者定义感兴趣的场景的三维物理尺寸L × W × H。然后，计算分辨率为dL × dW × dH的占用率特征，再计算分辨率为dL×dW×H的强度特征。注意，作者在占用率特征中增加了两个额外的通道，以覆盖范围外的点。最终表示的形状为L&#x2F;dL × W&#x2F;dW × (H&#x2F;dH + 3) </p>
<h3 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture"></a>Network Architecture</h3><p>PIXOR使用一个全卷积结构，设计用于密集定向的3D物体检测，并且没有使用类似于R-CNN的分支处理，相反网络在单个阶段输出像素预测，每个预测对应于3D对象估计。因此，根据定义，PIXOR的召回率是100%。多亏了完全非传统的架构，这样密集的预测可以非常有效地计算出来。就网络预测中3D对象的编码而言，作者构建了直接编码的模型，而不求助于预定义的object anchors。所有这些设计使得PIXOR变得非常简单，并且由于网络架构中的零超参数而得到很好的推广。具体来说，不需要设计object anchors，也不需要调整从第一阶段传递到第二阶段的关注区域以及相应的非最大抑制阈值。</p>
<p>整个体系结构可以分为两个子网络:主干网络Backbone network和头网络Header network。主干网络用于提取卷积特征并映射成输入的一般表示。它具有很高的表示能力来学习一个健壮的特征表示。头网络用于进行特定于任务的预测，在该例子中，它有一个具有多任务输出的单分支结构：对象分类和定位。<br><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh8muzjz2bj30h40dy0ti.jpg" alt="模型结构"></p>
<h3 id="Backbone-Network"><a href="#Backbone-Network" class="headerlink" title="Backbone Network"></a>Backbone Network</h3><p>卷积神经网络通常由卷积层和池化层组成。卷积图层用于提取输入要素的过度完整表示，而池化图层用于对要素地图大小进行下采样，以节省计算并帮助创建更健壮的表示。许多基于图像的物体检测器中的主干网络通常具有16倍下采样因子，并且通常被设计成具有更少的高分辨率层和更多的低分辨率层。它对图像很有效，因为对象通常像素尺寸很大。然而，在本文的情况下，这将导致一个问题，因为对象可能非常小。当离散分辨率为0.1m时，典型车辆的尺寸为18×40像素。16倍下采样后，它仅覆盖约3像素。</p>
<p>一个直接的解决方案是使用更少的池化层。然而，这将减小最终特征图中每个像素的感受野的大小，这限制了表现能力。另一个解决方案是使用膨胀卷积，但这将导致在高级特征地图中出现棋盘状伪像（checkerboard artifacts）。作者的解决方案很简单，使用16倍下采样因子，但是做了两个修改。首先，在较低的级别添加更多的通道数量较少的层，以提取更多的细节信息。其次，我们采用了类似FPN的自上而下的分支，将高分辨率特征图和低分辨率特征图相结合，以便对最终的特征表示进行上采样。</p>
<p>从Figure2可以看出主干网络中总共有五个层块。第一块由两个卷积层组成，通道为32，步长为1。第二至第五块由残差层组成（层数分别等于3、6、6、3）。每个残差块的第一卷积具有步长2，以便对特征图进行下采样。总的来说，下采样系数是16。为了对要素图进行上采样，其添加了一条自上而下的路径，每次对要素图进行2倍的上采样。然后，通过像素求和，这与相应分辨率的自下而上的特征图相结合。使用两个上采样层，这导致最终的特征图具有四倍下采样的大小。</p>
<h3 id="Header-Network"><a href="#Header-Network" class="headerlink" title="Header Network"></a>Header Network</h3><p>头网络是一个多任务网络——对象识别和方向定位。它被设计成小巧高效。分类分支输出1个通道特征图，跟sigmoid函数激活；回归分支输出线性的6通道特征图。在这两个分支之间分享权重的层数上存在权衡。一方面，我们希望更有效地利用重量。另一方面，由于它们是不同的子任务，我们希望它们更加独立和专业化。在下一章中，我们对这种权衡进行了一项调查性实验，发现两项任务的权重分配会带来稍微更好的性能。</p>
<p>我们将每个对象参数化为定向的bounding box b {θ，xc，yc，w，l}&#x3D;，每个元素对应于在[−π，π][−π，π]范围内的航向角、对象的中心位置(xc，yc)和对象的大小(w，l)。与基于长方体的三维物体检测相比，我们省略了沿Z轴的位置和尺寸，因为在像自主驾驶这样的应用中，感兴趣的物体被限制在同一个接地面上，因此我们只关心如何在那个平面上定位它。给定这样的参数化，回归分支的表示是{cos(θ)，sin(θ)，dx，dy，w，l}，对于位置(px，py)(如图3中的红点所示)。注意，航向角被分解为两个相关值，以加强角度范围约束。</p>
<p><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh8muzkdx8j30go0bs0th.jpg" alt="学习目标的定义"></p>
<p>在推理过程中，我们将θ解码为atan2(sin(θ)，cos(θ))。(dx，dy)对应于从像素位置到物体中心的位置偏移。(w，l)对应于对象大小。值得注意的是，对象位置和大小的值在现实世界的度量空间中。最后的学习目标是{cos(θ)，sin(θ)，dx，dy，log(w)，log(l)}，它在训练集之前被标准化为具有零均值和单位方差。</p>
<h3 id="Learning-and-Inference"><a href="#Learning-and-Inference" class="headerlink" title="Learning and Inference"></a>Learning and Inference</h3><p>与传统的多任务网络类似，其Loss的计算方式如下所示，其中focal_loss为分类的损失，smooth为回归的损失。<br><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh8muz8b1ej30fr06f74p.jpg" alt="损失函数"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-04-02T16:00:00.000Z" title="4/3/2020, 12:00:00 AM">2020-04-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-07-30T17:40:24.000Z" title="7/31/2020, 1:40:24 AM">2020-07-31</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></span><span class="level-item">5 minutes read (About 679 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/03/paper_birdnet/">基于鸟瞰图的点云目标检测：Birdnet+</a></h1><div class="content"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>自动驾驶汽车中的车载3D对象检测通常依赖于LiDAR设备捕获的几何信息。尽管通常优选使用图像特征进行检测，但是许多方法仅将空间数据作为输入。利用这些信息进行推理通常涉及使用紧凑的表示形式，例如鸟瞰图（BEV）投影，这会导致信息丢失，从而阻碍了对象3D框的所有参数的联合推理。在本文中，作者提出了一个完整的端到端3D对象检测框架，该框架可以通过使用两阶段对象检测器和临时回归分支仅从BEV图像中推断出定向3D框，从而无需进行后处理阶段。该方法在很大程度上优于其前身（BirdNet），并在KITTI 3D对象检测基准测试中获得了评估中所有类别的最新结果。<br><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh94w3hwayj30si0j4wmu.jpg"></p>
<h3 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h3><p>通过将点云数据投影为BEV表示将3D目标检测任务转化为2D图像检测问题，然后采用两阶段的Faster RCNN模型实现检测任务。<br><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gh94w07b1oj30ta0clabs.jpg">    </p>
<h3 id="技术细节："><a href="#技术细节：" class="headerlink" title="技术细节："></a>技术细节：</h3><ul>
<li><p><strong>BEV 表示:</strong> </p>
</li>
<li><p>将LIDAR点云数据编码成3个通道的2D结构，这三个通道为： 最大高度(&lt; 3m)，平均强度和单元格中的归一化点密度。</p>
</li>
<li><p>编码不包括每个单元的最低点信息（groud truth）</p>
</li>
<li><p>ROI 区域：前左右35m范围</p>
</li>
<li><p>单元网格的大小：每个单元网格的大小为5cm</p>
</li>
<li><p><strong>特征提取：</strong></p>
</li>
<li><p>采用ResNet-50网络，为了解决BEV视图下行人难以检测的问题，作者对ResNet-50做了一些修改：<br>(i)采用conv3 layer, 下采样因子设为8<br>(ii) 利用特征金字塔网络(FPN)一边从每个ResNet块的输出中提取每个对象对应的特征</p>
</li>
<li><p><strong>Region Proposal:</strong></p>
</li>
<li><p>anchor尺寸：16<em>16， 48</em>48， 80*80</p>
</li>
<li><p>anchor长宽比： 1:1, 1:2, 2:1</p>
</li>
<li><p>anchor是轴对齐的</p>
</li>
<li><p>Feature pooling分辨率： 7*7</p>
</li>
<li><p><strong>Classfication &amp; Bounding box regression</strong></p>
</li>
<li><p>RPN的第一阶段的proposals采用BEV图上的2D bounding box来表示，第二阶段负责对这些proposals进行分类。</p>
</li>
<li><p>预测步骤由两个全连接层完成， 每个层具有1024个元素，这些元素最终被馈送到一组individual heads中, 每个head由FC层组成并负责不同的任务，这些heads有三个分支，分别负责分类，轴对齐的框回归和离散的yaw的分类</p>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E6%9C%AF%E4%B8%9A/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/%E6%9C%AF%E4%B8%9A/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E6%9C%AF%E4%B8%9A/">1</a></li><li><a class="pagination-link" href="/categories/%E6%9C%AF%E4%B8%9A/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E6%9C%AF%E4%B8%9A/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%85%8E%E6%80%9D/"><span class="level-start"><span class="level-item">慎思</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%AF%E4%B8%9A/"><span class="level-start"><span class="level-item">术业</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%8E%A9%E7%89%A9/"><span class="level-start"><span class="level-item">玩物</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T14:52:03.519Z">2022-03-20</time></p><p class="title"><a href="/2022/03/20/work/matplotlib/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T14:52:03.515Z">2022-03-20</time></p><p class="title"><a href="/2022/03/20/work/003.Autosar/"> </a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/09/work/005.FreeRTOS/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="FreeRTOS学习笔记02"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-08T16:00:00.000Z">2021-05-09</time></p><p class="title"><a href="/2021/05/09/work/005.FreeRTOS/">FreeRTOS学习笔记02</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/07/work/004.RTOS/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="FreeRTOS学习笔记01"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-06T16:00:00.000Z">2021-05-07</time></p><p class="title"><a href="/2021/05/07/work/004.RTOS/">FreeRTOS学习笔记01</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/03/work/Emmbed_system_QA/"><img src="http://ww1.sinaimg.cn/large/006E0Yd9gy1gaeafbwql6j30sg0g0aa5.jpg" alt="嵌入式面试常见问题整理"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-02T16:00:00.000Z">2021-05-03</time></p><p class="title"><a href="/2021/05/03/work/Emmbed_system_QA/">嵌入式面试常见问题整理</a></p><p class="categories"><a href="/categories/%E6%9C%AF%E4%B8%9A/">术业</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">February 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">February 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Apollo/"><span class="tag">Apollo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Blogs/"><span class="tag">Blogs</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CV/"><span class="tag">CV</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Self-driving/"><span class="tag">Self-driving</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tensorflow/"><span class="tag">Tensorflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nvidia/"><span class="tag">nvidia</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/object-detection/"><span class="tag">object detection</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/photo/"><span class="tag">photo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/point-cloud/"><span class="tag">point cloud</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pytorch/"><span class="tag">pytorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"><span class="tag">嵌入式</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BB%BA%E6%A8%A1/"><span class="tag">建模</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%B7%E5%9B%BD%E9%A9%BE%E7%85%A7/"><span class="tag">德国驾照</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%88%AA%E6%8B%8D/"><span class="tag">航拍</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2022 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>